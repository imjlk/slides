const __vite__mapDeps = (i, m = __vite__mapDeps, d = (m.f || (m.f = ["assets/slidev/md-ClF0X0E-.js", "assets/modules/unplugin-icons-ydpWw-S1.js", "assets/modules/vue-DPfvC9Rf.js", "assets/slidev/context-C_sXOc74.js", "assets/monaco/bundled-types-BuzDbTDI.js", "assets/modules/file-saver-BzOOqXCn.js", "assets/monaco/bundled-types-DCzMN06e.css", "assets/modules/shiki-B2I2iqOa.js", "assets/modules/shiki-Bxv373Z5.css", "assets/md-Bz5fzyVD.js", "assets/slidev/default-B6ES7psX.js", "assets/md-DXR_J10G.js", "assets/md-u0t74C3C.css", "assets/md-DfC3lTnY.js", "assets/md-tSVJnXGJ.js", "assets/md-ClMJk-CZ.js", "assets/slidev/md-DCbXe0MZ.js", "assets/slidev/title-renderer.md_vue_type_script_setup_true_lang-CBqWlV7x.js", "assets/slidev/CodeBlockWrapper.vue_vue_type_script_setup_true_lang-DdKkH5rC.js", "assets/md-d5FwiuyQ.css", "assets/md-BZ47sGWi.js", "assets/md-Kk7YH67r.js", "assets/slidev/Arrow.vue_vue_type_script_setup_true_lang-CnvcwacB.js", "assets/md-BK4Rmvom.css", "assets/md-C38cacXh.js", "assets/md-CgZ1jk1v.js", "assets/lz-string-BcNN3PhA.js", "assets/md-D7mj9DLL.css", "assets/slidev/md-v3iux9r6.js", "assets/md-gFVChr0L.css", "assets/md-Dgs6EzeQ.js", "assets/md-DiSIfiz7.js", "assets/slidev/md-C8mWdNCw.js", "assets/md-C2rd2vpG.js", "assets/slidev/md-CAUzu8Ki.js", "assets/md-ZFnz3MWp.js", "assets/md-Dp083uOp.js", "assets/md-CZXri9e8.js", "assets/md-oUrpCq9S.js", "assets/md-ucEVbFgb.js", "assets/md-w_foF71n.js", "assets/md-C0e9YJXa.js", "assets/md-CtkpCW-j.js", "assets/slidev/md-FX75wghA.js", "assets/md-7jFczfCX.js", "assets/md-BsbvjOIv.js", "assets/slidev/md-CZ3auH7d.js", "assets/md-COspDR16.css", "assets/md-CSdA9JEq.js", "assets/slidev/md-Brewg9zi.js", "assets/slidev/entry-DfZBjPkM.js", "assets/entry-15QH0Q6e.css", "assets/slidev/overview-velCqymH.js", "assets/slidev/NoteDisplay.vue_vue_type_style_index_0_lang-DyeUpVC4.js", "assets/NoteDisplay-CGTG5ZHT.css", "assets/slidev/SlideWrapper-D-nFbPsV.js", "assets/SlideWrapper-Clw4pYGY.css", "assets/slidev/IconButton.vue_vue_type_script_setup_true_lang-j3ryI2jJ.js", "assets/slidev/notes-CrVn7Iap.js", "assets/slidev/presenter-kGzephC-.js", "assets/slidev/shortcuts-Cn-cQfq8.js", "assets/shortcuts-BbJOi48n.css", "assets/slidev/DrawingControls.vue_vue_type_style_index_0_lang-DIIizENl.js", "assets/DrawingControls-Cxk9a9ub.css", "assets/presenter-DHVy2-lk.css", "assets/slidev/play-LOwe0LLh.js", "assets/play-D_7yfuao.css", "assets/slidev/404-t6LltpjP.js", "assets/404-n_Eqdu3W.css"]))) => i.map(i => d[i]);
import { ad as qs, aa as Cr, aC as Dr, av as Ws, r as D, G as ne, U as Ir, aD as Rr, aE as Nr, al as Us, z as S, Q as Js, aF as P, aG as jr, P as Hr, f as pn, o as je, t as xr, d as Ks, i as Vr, F as Fr, g as Jn, Y as E, Z as Pn, a2 as zr, T as Je, p as Gs, I as Br, aH as qr, aI as Wr, aJ as Ur, aK as Jr, aL as Kr, B as U, C as Gr, D as An, aM as Qr, ah as Qs, E as ot, aN as Yr, aO as Zr, aP as Ys, b as Xr, a as to, ap as eo, S as no, a8 as so, M as ro, aQ as oo, aR as io, aS as ao, c as lo } from "./modules/vue-DPfvC9Rf.js"; import { u as co, f as gn, _ as $, r as Kn, v as uo, c as J, k as fo, l as ho, n as po, s as en, w as go } from "./monaco/bundled-types-BuzDbTDI.js"; import { T as mo } from "./modules/shiki-B2I2iqOa.js"; import "./modules/file-saver-BzOOqXCn.js"; (function () { const t = document.createElement("link").relList; if (t && t.supports && t.supports("modulepreload")) return; for (const r of document.querySelectorAll('link[rel="modulepreload"]')) s(r); new MutationObserver(r => { for (const o of r) if (o.type === "childList") for (const i of o.addedNodes) i.tagName === "LINK" && i.rel === "modulepreload" && s(i) }).observe(document, { childList: !0, subtree: !0 }); function e(r) { const o = {}; return r.integrity && (o.integrity = r.integrity), r.referrerPolicy && (o.referrerPolicy = r.referrerPolicy), r.crossOrigin === "use-credentials" ? o.credentials = "include" : r.crossOrigin === "anonymous" ? o.credentials = "omit" : o.credentials = "same-origin", o } function s(r) { if (r.ep) return; r.ep = !0; const o = e(r); fetch(r.href, o) } })(); const yo = [], _o = new Set(["link", "style", "script", "noscript"]), vo = new Set(["title", "titleTemplate", "script", "style", "noscript"]), Gn = new Set(["base", "meta", "link", "style", "script", "noscript"]), ko = new Set(["title", "base", "htmlAttrs", "bodyAttrs", "meta", "link", "style", "script", "noscript"]), wo = new Set(["base", "title", "titleTemplate", "bodyAttrs", "htmlAttrs", "templateParams"]), bo = new Set(["key", "tagPosition", "tagPriority", "tagDuplicateStrategy", "innerHTML", "textContent", "processTemplateParams"]), So = new Set(["templateParams", "htmlAttrs", "bodyAttrs"]), Mo = new Set(["theme-color", "google-site-verification", "og", "article", "book", "profile", "twitter", "author"]); function mn(n, t = {}, e) { for (const s in n) { const r = n[s], o = e ? `${e}:${s}` : s; typeof r == "object" && r !== null ? mn(r, t, o) : typeof r == "function" && (t[o] = r) } return t } const Oo = { run: n => n() }, $o = () => Oo, Zs = typeof console.createTask < "u" ? console.createTask : $o; function Lo(n, t) { const e = t.shift(), s = Zs(e); return n.reduce((r, o) => r.then(() => s.run(() => o(...t))), Promise.resolve()) } function Eo(n, t) { const e = t.shift(), s = Zs(e); return Promise.all(n.map(r => s.run(() => r(...t)))) } function nn(n, t) { for (const e of [...n]) e(t) } class To { constructor() { this._hooks = {}, this._before = void 0, this._after = void 0, this._deprecatedMessages = void 0, this._deprecatedHooks = {}, this.hook = this.hook.bind(this), this.callHook = this.callHook.bind(this), this.callHookWith = this.callHookWith.bind(this) } hook(t, e, s = {}) { if (!t || typeof e != "function") return () => { }; const r = t; let o; for (; this._deprecatedHooks[t];)o = this._deprecatedHooks[t], t = o.to; if (o && !s.allowDeprecated) { let i = o.message; i || (i = `${r} hook has been deprecated` + (o.to ? `, please use ${o.to}` : "")), this._deprecatedMessages || (this._deprecatedMessages = new Set), this._deprecatedMessages.has(i) || (console.warn(i), this._deprecatedMessages.add(i)) } if (!e.name) try { Object.defineProperty(e, "name", { get: () => "_" + t.replace(/\W+/g, "_") + "_hook_cb", configurable: !0 }) } catch { } return this._hooks[t] = this._hooks[t] || [], this._hooks[t].push(e), () => { e && (this.removeHook(t, e), e = void 0) } } hookOnce(t, e) { let s, r = (...o) => (typeof s == "function" && s(), s = void 0, r = void 0, e(...o)); return s = this.hook(t, r), s } removeHook(t, e) { if (this._hooks[t]) { const s = this._hooks[t].indexOf(e); s !== -1 && this._hooks[t].splice(s, 1), this._hooks[t].length === 0 && delete this._hooks[t] } } deprecateHook(t, e) { this._deprecatedHooks[t] = typeof e == "string" ? { to: e } : e; const s = this._hooks[t] || []; delete this._hooks[t]; for (const r of s) this.hook(t, r) } deprecateHooks(t) { Object.assign(this._deprecatedHooks, t); for (const e in t) this.deprecateHook(e, t[e]) } addHooks(t) { const e = mn(t), s = Object.keys(e).map(r => this.hook(r, e[r])); return () => { for (const r of s.splice(0, s.length)) r() } } removeHooks(t) { const e = mn(t); for (const s in e) this.removeHook(s, e[s]) } removeAllHooks() { for (const t in this._hooks) delete this._hooks[t] } callHook(t, ...e) { return e.unshift(t), this.callHookWith(Lo, t, ...e) } callHookParallel(t, ...e) { return e.unshift(t), this.callHookWith(Eo, t, ...e) } callHookWith(t, e, ...s) { const r = this._before || this._after ? { name: e, args: s, context: {} } : void 0; this._before && nn(this._before, r); const o = t(e in this._hooks ? [...this._hooks[e]] : [], s); return o instanceof Promise ? o.finally(() => { this._after && r && nn(this._after, r) }) : (this._after && r && nn(this._after, r), o) } beforeEach(t) { return this._before = this._before || [], this._before.push(t), () => { if (this._before !== void 0) { const e = this._before.indexOf(t); e !== -1 && this._before.splice(e, 1) } } } afterEach(t) { return this._after = this._after || [], this._after.push(t), () => { if (this._after !== void 0) { const e = this._after.indexOf(t); e !== -1 && this._after.splice(e, 1) } } } } function Po() { return new To } const Ao = ["name", "property", "http-equiv"]; function Xs(n) { const t = n.split(":")[1]; return Mo.has(t) } function yn(n) { const { props: t, tag: e } = n; if (wo.has(e)) return e; if (e === "link" && t.rel === "canonical") return "canonical"; if (t.charset) return "charset"; if (n.tag === "meta") { for (const s of Ao) if (t[s] !== void 0) return `${e}:${t[s]}` } if (n.key) return `${e}:key:${n.key}`; if (t.id) return `${e}:id:${t.id}`; if (vo.has(e)) { const s = n.textContent || n.innerHTML; if (s) return `${e}:content:${s}` } } function Qn(n) { const t = n._h || n._d; if (t) return t; const e = n.textContent || n.innerHTML; return e || `${n.tag}:${Object.entries(n.props).map(([s, r]) => `${s}:${String(r)}`).join(",")}` } function He(n, t, e) { typeof n === "function" && (!e || e !== "titleTemplate" && !(e[0] === "o" && e[1] === "n")) && (n = n()); let r; if (t && (r = t(e, n)), Array.isArray(r)) return r.map(o => He(o, t)); if ((r == null ? void 0 : r.constructor) === Object) { const o = {}; for (const i of Object.keys(r)) o[i] = He(r[i], t, i); return o } return r } function Co(n, t) { const e = n === "style" ? new Map : new Set; function s(r) { const o = r.trim(); if (o) if (n === "style") { const [i, ...a] = o.split(":").map(l => l.trim()); i && a.length && e.set(i, a.join(":")) } else o.split(" ").filter(Boolean).forEach(i => e.add(i)) } return typeof t == "string" ? n === "style" ? t.split(";").forEach(s) : s(t) : Array.isArray(t) ? t.forEach(r => s(r)) : t && typeof t == "object" && Object.entries(t).forEach(([r, o]) => { o && o !== "false" && (n === "style" ? e.set(r.trim(), o) : s(r)) }), e } function tr(n, t) { return n.props = n.props || {}, t && Object.entries(t).forEach(([e, s]) => { if (s === null) { n.props[e] = null; return } if (e === "class" || e === "style") { n.props[e] = Co(e, s); return } if (bo.has(e)) { if (["textContent", "innerHTML"].includes(e) && typeof s == "object") { let i = t.type; if (t.type || (i = "application/json"), !(i != null && i.endsWith("json")) && i !== "speculationrules") return; t.type = i, n.props.type = i, n[e] = JSON.stringify(s) } else n[e] = s; return } const r = String(s), o = e.startsWith("data-"); r === "true" || r === "" ? n.props[e] = o ? r : !0 : !s && o && r === "false" ? n.props[e] = "false" : s !== void 0 && (n.props[e] = s) }), n } function Do(n, t) { const e = typeof t == "object" && typeof t != "function" ? t : { [n === "script" || n === "noscript" || n === "style" ? "innerHTML" : "textContent"]: t }, s = tr({ tag: n, props: {} }, e); return s.key && _o.has(s.tag) && (s.props["data-hid"] = s._h = s.key), s.tag === "script" && typeof s.innerHTML == "object" && (s.innerHTML = JSON.stringify(s.innerHTML), s.props.type = s.props.type || "application/json"), Array.isArray(s.props.content) ? s.props.content.map(r => ({ ...s, props: { ...s.props, content: r } })) : s } function Io(n, t) { if (!n) return []; typeof n == "function" && (n = n()); const e = (r, o) => { for (let i = 0; i < t.length; i++)o = t[i](r, o); return o }; n = e(void 0, n); const s = []; return n = He(n, e), Object.entries(n || {}).forEach(([r, o]) => { if (o !== void 0) for (const i of Array.isArray(o) ? o : [o]) s.push(Do(r, i)) }), s.flat() } const Yn = (n, t) => n._w === t._w ? n._p - t._p : n._w - t._w, Zn = { base: -10, title: 10 }, Ro = { critical: -8, high: -1, low: 2 }, Xn = { meta: { "content-security-policy": -30, charset: -20, viewport: -15 }, link: { preconnect: 20, stylesheet: 60, preload: 70, modulepreload: 70, prefetch: 90, "dns-prefetch": 90, prerender: 90 }, script: { async: 30, defer: 80, sync: 50 }, style: { imported: 40, sync: 60 } }, No = /@import/, le = n => n === "" || n === !0; function jo(n, t) { var o; if (typeof t.tagPriority == "number") return t.tagPriority; let e = 100; const s = Ro[t.tagPriority] || 0, r = n.resolvedOptions.disableCapoSorting ? { link: {}, script: {}, style: {} } : Xn; if (t.tag in Zn) e = Zn[t.tag]; else if (t.tag === "meta") { const i = t.props["http-equiv"] === "content-security-policy" ? "content-security-policy" : t.props.charset ? "charset" : t.props.name === "viewport" ? "viewport" : null; i && (e = Xn.meta[i]) } else t.tag === "link" && t.props.rel ? e = r.link[t.props.rel] : t.tag === "script" ? le(t.props.async) ? e = r.script.async : t.props.src && !le(t.props.defer) && !le(t.props.async) && t.props.type !== "module" && !((o = t.props.type) != null && o.endsWith("json")) ? e = r.script.sync : le(t.props.defer) && t.props.src && !le(t.props.async) && (e = r.script.defer) : t.tag === "style" && (e = t.innerHTML && No.test(t.innerHTML) ? r.style.imported : r.style.sync); return (e || 100) + s } function ts(n, t) { const e = typeof t == "function" ? t(n) : t, s = e.key || String(n.plugins.size + 1); n.plugins.get(s) || (n.plugins.set(s, e), n.hooks.addHooks(e.hooks || {})) } function Ho(n = {}) { var a; const t = Po(); t.addHooks(n.hooks || {}); const e = !n.document, s = new Map, r = new Map, o = [], i = { _entryCount: 1, plugins: r, dirty: !1, resolvedOptions: n, hooks: t, ssr: e, entries: s, headEntries() { return [...s.values()] }, use: l => ts(i, l), push(l, c) { const u = { ...c || {} }; delete u.head; const f = u._index ?? i._entryCount++, g = { _i: f, input: l, options: u }, h = { _poll(p = !1) { i.dirty = !0, !p && o.push(f), t.callHook("entries:updated", i) }, dispose() { s.delete(f) && h._poll(!0) }, patch(p) { (!u.mode || u.mode === "server" && e || u.mode === "client" && !e) && (g.input = p, s.set(f, g), h._poll()) } }; return h.patch(l), h }, async resolveTags() { var h; const l = { tagMap: new Map, tags: [], entries: [...i.entries.values()] }; for (await t.callHook("entries:resolve", l); o.length;) { const p = o.shift(), d = s.get(p); if (d) { const m = { tags: Io(d.input, n.propResolvers || []).map(_ => Object.assign(_, d.options)), entry: d }; await t.callHook("entries:normalize", m), d._tags = m.tags.map((_, y) => (_._w = jo(i, _), _._p = (d._i << 10) + y, _._d = yn(_), _)) } } let c = !1; l.entries.flatMap(p => (p._tags || []).map(d => ({ ...d, props: { ...d.props } }))).sort(Yn).reduce((p, d) => { const m = String(d._d || d._p); if (!p.has(m)) return p.set(m, d); const _ = p.get(m); if (((d == null ? void 0 : d.tagDuplicateStrategy) || (So.has(d.tag) ? "merge" : null) || (d.key && d.key === _.key ? "merge" : null)) === "merge") { const k = { ..._.props }; Object.entries(d.props).forEach(([w, b]) => k[w] = w === "style" ? new Map([..._.props.style || new Map, ...b]) : w === "class" ? new Set([..._.props.class || new Set, ...b]) : b), p.set(m, { ...d, props: k }) } else d._p >> 10 === _._p >> 10 && Xs(d._d) ? (p.set(m, Object.assign([...Array.isArray(_) ? _ : [_], d], d)), c = !0) : (d._w === _._w ? d._p > _._p : (d == null ? void 0 : d._w) < (_ == null ? void 0 : _._w)) && p.set(m, d); return p }, l.tagMap); const u = l.tagMap.get("title"), f = l.tagMap.get("titleTemplate"); if (i._title = u == null ? void 0 : u.textContent, f) { const p = f == null ? void 0 : f.textContent; if (i._titleTemplate = typeof p == "string" ? p : void 0, p) { let d = typeof p == "function" ? p(u == null ? void 0 : u.textContent) : p; typeof d == "string" && !i.plugins.has("template-params") && (d = d.replace("%s", (u == null ? void 0 : u.textContent) || "")), u ? d === null ? l.tagMap.delete("title") : l.tagMap.set("title", { ...u, textContent: d }) : (f.tag = "title", f.textContent = d) } } l.tags = Array.from(l.tagMap.values()), c && (l.tags = l.tags.flat().sort(Yn)), await t.callHook("tags:beforeResolve", l), await t.callHook("tags:resolve", l), await t.callHook("tags:afterResolve", l); const g = []; for (const p of l.tags) { const { innerHTML: d, tag: m, props: _ } = p; if (ko.has(m) && !(Object.keys(_).length === 0 && !p.innerHTML && !p.textContent) && !(m === "meta" && !_.content && !_["http-equiv"] && !_.charset)) { if (m === "script" && d) { if ((h = _.type) != null && h.endsWith("json")) { const y = typeof d == "string" ? d : JSON.stringify(d); p.innerHTML = y.replace(/</g, "\\u003C") } else typeof d == "string" && (p.innerHTML = d.replace(new RegExp(`</${m}`, "g"), `<\\/${m}`)); p._d = yn(p) } g.push(p) } } return g } }; return ((n == null ? void 0 : n.plugins) || []).forEach(l => ts(i, l)), i.hooks.callHook("init", i), (a = n.init) == null || a.forEach(l => l && i.push(l)), i } const xo = (n, t) => Cr(t) ? qs(t) : t, er = "usehead"; function Vo(n) { return { install(e) { e.config.globalProperties.$unhead = n, e.config.globalProperties.$head = n, e.provide(er, n) } }.install } function Fo() { if (Dr()) { const n = Ws(er); if (!n) throw new Error("useHead() was called without provide context, ensure you call it through the setup() function."); return n } throw new Error("useHead() was called without provide context, ensure you call it through the setup() function.") } function zo(n, t = {}) { const e = t.head || Fo(); return e.ssr ? e.push(n || {}, t) : Bo(e, n, t) } function Bo(n, t, e = {}) { const s = D(!1); let r; return ne(() => { const i = s.value ? {} : He(t, xo); r ? r.patch(i) : r = n.push(i, e) }), Us() && (Ir(() => { r.dispose() }), Rr(() => { s.value = !0 }), Nr(() => { s.value = !1 })), r } function _n(n) { if (n === !1 || n === "false") return null; if (n == null || n === !0 || n === "true") return "+1"; if (typeof n == "string" && "+-".includes(n[0])) return n; const t = +n; return Number.isNaN(t) ? (console.error(`Invalid "at" prop value: ${n}`), null) : t } function qo(n) { return Array.isArray(n) ? [_n(n[0]), _n(n[1])] : null } function nr(n, t = 0, e) { const s = D(!1); let r = new Map, o = new Map; const i = { get current() { return gn(+n.value, t, i.total) }, set current(a) { n.value = s.value ? gn(a, t, i.total) : a }, clicksStart: t, get relativeSizeMap() { return r }, get maxMap() { return o }, get isMounted() { return s.value }, setup() { Js(() => { s.value = !0, o = P(o), jr(n) || (i.current = n.value) }), Hr(() => { s.value = !1, r = new Map, o = new Map }) }, calculateSince(a, l = 1) { const c = _n(a); if (c == null) return null; let u, f, g; if (typeof c == "string") { const h = i.currentOffset, p = +c; u = h + p, f = h + p + l - 1, g = p + l - 1 } else u = c, f = c + l - 1, g = 0; return { start: u, end: +Number.POSITIVE_INFINITY, max: f, delta: g, currentOffset: S(() => i.current - u), isCurrent: S(() => i.current === u), isActive: S(() => i.current >= u) } }, calculateRange(a) { const l = qo(a); if (l == null) return null; const [c, u] = l; let f, g, h; return typeof c == "string" ? (f = i.currentOffset + +c, h = +c) : (f = c, h = 0), typeof u == "string" ? (g = f + +u, h += +u) : g = u, { start: f, end: g, max: g, delta: h, currentOffset: S(() => i.current - f), isCurrent: S(() => i.current === f), isActive: S(() => f <= i.current && i.current < g) } }, calculate(a) { return Array.isArray(a) ? i.calculateRange(a) : i.calculateSince(a) }, register(a, l) { if (!l) return; const { delta: c, max: u } = l; r.set(a, c), o.set(a, u) }, unregister(a) { r.delete(a), o.delete(a) }, get currentOffset() { return co(...r.values()) }, get total() { return e ?? (s.value ? Math.max(0, ...o.values()) : 0) } }; return i } function Wo(n, t = 0) { var s, r; const e = ((s = n == null ? void 0 : n.meta.slide) == null ? void 0 : s.frontmatter.clicksStart) ?? 0; return nr(S(() => Math.max(qs(t), e)), e, (r = n == null ? void 0 : n.meta) == null ? void 0 : r.clicks) } const Uo = (n, t) => { const e = n.__vccOpts || n; for (const [s, r] of t) e[s] = r; return e }, Jo = {}, Ko = { class: "px-4 py-10 text-center text-red-700 dark:text-red-500 font-bold font-mono" }; function Go(n, t) { return je(), pn("div", Ko, xr("Failed to fetch this slide. Please check your network connection.")) } const A = Uo(Jo, [["render", Go]]), Qo = { class: "h-full w-full flex items-center justify-center gap-2 slidev-slide-loading" }, Yo = Ks({ __name: "SlideLoading", setup(n) { const t = D(!1); return Js(() => { setTimeout(() => { t.value = !0 }, 200) }), (e, s) => (je(), pn("div", Qo, [t.value ? (je(), pn(Fr, { key: 0 }, [s[0] || (s[0] = Jn("div", { class: "i-svg-spinners-90-ring-with-bg text-xl" }, null, -1)), s[1] || (s[1] = Jn("div", null, "Loading slide...", -1))], 64)) : Vr("v-if", !0)])) } }), Zo = {
  theme: "seriph", title: "ì•„ì´ë””ì–´ í’ˆí‰íšŒ", info: `## Slidev Starter Template
Presentation slides for developers.

Learn more at [Sli.dev](https://sli.dev)
`, class: "text-center", transition: "slide-left", mdc: !0, overviewSnapshots: !0, addons: ["@harshil1712/slidev-addon-live-reactions"], liveReactions: { server: "wss://slidev-realtime-feedback-do.1990c.workers.dev", okay: "ğŸ‘€", good: "ğŸ‘", great: "â¤ï¸", mindBlown: "ğŸ¤¯" }, auth: { passwordUrl: "/auth" }, routerMode: "hash"
}, ht = E(Zo), Xo = P({
  get layout() { return ht.layout }, get transition() { return ht.transition }, get class() { return ht.class }, get clicks() { return ht.clicks }, get name() { return ht.name }, get preload() { return ht.preload }, slide: {
    content: "", revision: "-yf52sz", frontmatterRaw: `# You can also start simply with 'default'
theme: seriph
# random image from a curated Unsplash collection by Anthony
# like them? see https://unsplash.com/collections/94734566/slidev
# background: https://cover.sli.dev
# some information about your slides (markdown enabled)
title: ì•„ì´ë””ì–´ í’ˆí‰íšŒ
info: |
  ## Slidev Starter Template
  Presentation slides for developers.

  Learn more at [Sli.dev](https://sli.dev)
# apply unocss classes to the current slide
class: text-center
# slide transition: https://sli.dev/guide/animations.html#slide-transitions
transition: slide-left
# enable MDC Syntax: https://sli.dev/features/mdc
mdc: true
# take snapshot for each slide in the overview
overviewSnapshots: true
addons:
  # - '@harshil1712/slidev-addon-protected-presenter'
  - '@harshil1712/slidev-addon-live-reactions'
liveReactions:
  server: wss://slidev-realtime-feedback-do.1990c.workers.dev
  okay: ğŸ‘€
  good: ğŸ‘
  great: â¤ï¸
  mindBlown: ğŸ¤¯
auth:
  passwordUrl: /auth

routerMode: hash

`, note: "", title: "ì•„ì´ë””ì–´ í’ˆí‰íšŒ", index: 0, noteHTML: `<p>The last comment block of each slide will be treated as slide notes. It will be visible and editable in Presenter Mode along with the slide. <a href="https://sli.dev/guide/syntax.html#notes" target="_blank">Read more in the docs</a></p>
`, raw: "", frontmatter: ht, filepath: "", start: 0, id: 0, no: 1
  }, __clicksContext: null, __preloaded: !1
}), ti = {}, pt = E(ti), ei = P({ get layout() { return pt.layout }, get transition() { return pt.transition }, get class() { return pt.class }, get clicks() { return pt.clicks }, get name() { return pt.name }, get preload() { return pt.preload }, slide: { content: "", revision: "pil5fc", note: "", index: 1, noteHTML: "", raw: "", frontmatter: pt, filepath: "", start: 52, id: 1, no: 2 }, __clicksContext: null, __preloaded: !1 }), ni = {}, gt = E(ni), si = P({
  get layout() { return gt.layout }, get transition() { return gt.transition }, get class() { return gt.class }, get clicks() { return gt.clicks }, get name() { return gt.name }, get preload() { return gt.preload }, slide: {
    content: "", revision: "-ntqe1a", note: "", title: "What is Slidev?", level: 1, index: 2, noteHTML: `<p>Here is another comment.</p>
`, raw: "", frontmatter: gt, filepath: "", start: 55, id: 2, no: 3
  }, __clicksContext: null, __preloaded: !1
}), ri = {}, mt = E(ri), oi = P({ get layout() { return mt.layout }, get transition() { return mt.transition }, get class() { return mt.class }, get clicks() { return mt.clicks }, get name() { return mt.name }, get preload() { return mt.preload }, slide: { content: "", revision: "mv55eo", note: "", index: 3, noteHTML: "", raw: "", frontmatter: mt, filepath: "", start: 95, id: 3, no: 4 }, __clicksContext: null, __preloaded: !1 }), ii = {}, yt = E(ii), ai = P({ get layout() { return yt.layout }, get transition() { return yt.transition }, get class() { return yt.class }, get clicks() { return yt.clicks }, get name() { return yt.name }, get preload() { return yt.preload }, slide: { content: "", revision: "yraex8", note: "", title: "Navigation", level: 1, index: 4, noteHTML: "", raw: "", frontmatter: yt, filepath: "", start: 99, id: 4, no: 5 }, __clicksContext: null, __preloaded: !1 }), li = {}, _t = E(li), ci = P({ get layout() { return _t.layout }, get transition() { return _t.transition }, get class() { return _t.class }, get clicks() { return _t.clicks }, get name() { return _t.name }, get preload() { return _t.preload }, slide: { content: "", revision: "ijvi7e", note: "", index: 5, noteHTML: "", raw: "", frontmatter: _t, filepath: "", start: 123, id: 5, no: 6 }, __clicksContext: null, __preloaded: !1 }), ui = {}, vt = E(ui), fi = P({ get layout() { return vt.layout }, get transition() { return vt.transition }, get class() { return vt.class }, get clicks() { return vt.clicks }, get name() { return vt.name }, get preload() { return vt.preload }, slide: { content: "", revision: "nwh3t9", note: "", title: "Table of contents", level: 1, index: 6, noteHTML: "", raw: "", frontmatter: vt, filepath: "", start: 127, id: 6, no: 7 }, __clicksContext: null, __preloaded: !1 }), di = {}, kt = E(di), hi = P({ get layout() { return kt.layout }, get transition() { return kt.transition }, get class() { return kt.class }, get clicks() { return kt.clicks }, get name() { return kt.name }, get preload() { return kt.preload }, slide: { content: "", revision: "f20d14", note: "", index: 7, noteHTML: "", raw: "", frontmatter: kt, filepath: "", start: 143, id: 7, no: 8 }, __clicksContext: null, __preloaded: !1 }), pi = {}, wt = E(pi), gi = P({
  get layout() { return wt.layout }, get transition() { return wt.transition }, get class() { return wt.class }, get clicks() { return wt.clicks }, get name() { return wt.name }, get preload() { return wt.preload }, slide: {
    content: "", revision: "-it0546", note: "", title: "Code", level: 1, index: 8, noteHTML: `<p>Notes can also sync with clicks</p>
<p><span class="slidev-note-click-mark" data-clicks="1"></span> This will be highlighted after the first click</p>
<p><span class="slidev-note-click-mark" data-clicks="2"></span> Highlighted with <code>count = ref(0)</code></p>
<p><span class="slidev-note-click-mark" data-clicks="5"></span> Last click (skip two clicks)</p>
`, raw: "", frontmatter: wt, filepath: "", start: 147, id: 8, no: 9
  }, __clicksContext: null, __preloaded: !1
}), mi = {}, bt = E(mi), yi = P({ get layout() { return bt.layout }, get transition() { return bt.transition }, get class() { return bt.class }, get clicks() { return bt.clicks }, get name() { return bt.name }, get preload() { return bt.preload }, slide: { content: "", revision: "-z94yew", note: "", index: 9, noteHTML: "", raw: "", frontmatter: bt, filepath: "", start: 198, id: 9, no: 10 }, __clicksContext: null, __preloaded: !1 }), _i = {}, St = E(_i), vi = P({ get layout() { return St.layout }, get transition() { return St.transition }, get class() { return St.class }, get clicks() { return St.clicks }, get name() { return St.name }, get preload() { return St.preload }, slide: { content: "", revision: "-2dskxh", note: "", title: "Shiki Magic Move", level: 1, index: 10, noteHTML: "", raw: "", frontmatter: St, filepath: "", start: 201, id: 10, no: 11 }, __clicksContext: null, __preloaded: !1 }), ki = {}, Mt = E(ki), wi = P({
  get layout() { return Mt.layout }, get transition() { return Mt.transition }, get class() { return Mt.class }, get clicks() { return Mt.clicks }, get name() { return Mt.name }, get preload() { return Mt.preload }, slide: {
    content: "", revision: "ae1u8", note: "", title: "Components", level: 1, index: 11, noteHTML: `<p>Presenter note with <strong>bold</strong>, <em>italic</em>, and <s>striked</s> text.</p>
<p>Also, HTML elements are valid:</p>
<div class="flex w-full">
  <span style="flex-grow: 1;">Left content</span>
  <span>Right content</span>
</div>`, raw: "", frontmatter: Mt, filepath: "", start: 273, id: 11, no: 12
  }, __clicksContext: null, __preloaded: !1
}), bi = {}, Ot = E(bi), Si = P({ get layout() { return Ot.layout }, get transition() { return Ot.transition }, get class() { return Ot.class }, get clicks() { return Ot.clicks }, get name() { return Ot.name }, get preload() { return Ot.preload }, slide: { content: "", revision: "-b314fv", note: "", index: 12, noteHTML: "", raw: "", frontmatter: Ot, filepath: "", start: 315, id: 12, no: 13 }, __clicksContext: null, __preloaded: !1 }), Mi = {}, $t = E(Mi), Oi = P({ get layout() { return $t.layout }, get transition() { return $t.transition }, get class() { return $t.class }, get clicks() { return $t.clicks }, get name() { return $t.name }, get preload() { return $t.preload }, slide: { content: "", revision: "-328eij", note: "", title: "Themes", level: 1, index: 13, noteHTML: "", raw: "", frontmatter: $t, filepath: "", start: 318, id: 13, no: 14 }, __clicksContext: null, __preloaded: !1 }), $i = {}, Lt = E($i), Li = P({ get layout() { return Lt.layout }, get transition() { return Lt.transition }, get class() { return Lt.class }, get clicks() { return Lt.clicks }, get name() { return Lt.name }, get preload() { return Lt.preload }, slide: { content: "", revision: "90rao3", note: "", title: "Clicks Animations", level: 1, index: 14, noteHTML: "", raw: "", frontmatter: Lt, filepath: "", start: 347, id: 14, no: 15 }, __clicksContext: null, __preloaded: !1 }), Ei = {}, Et = E(Ei), Ti = P({ get layout() { return Et.layout }, get transition() { return Et.transition }, get class() { return Et.class }, get clicks() { return Et.clicks }, get name() { return Et.name }, get preload() { return Et.preload }, slide: { content: "", revision: "-pxdxpj", note: "", title: "Motions", level: 1, index: 15, noteHTML: "", raw: "", frontmatter: Et, filepath: "", start: 384, id: 15, no: 16 }, __clicksContext: null, __preloaded: !1 }), Pi = {}, Tt = E(Pi), Ai = P({ get layout() { return Tt.layout }, get transition() { return Tt.transition }, get class() { return Tt.class }, get clicks() { return Tt.clicks }, get name() { return Tt.name }, get preload() { return Tt.preload }, slide: { content: "", revision: "-5o1i3g", note: "", title: "LaTeX", level: 1, index: 16, noteHTML: "", raw: "", frontmatter: Tt, filepath: "", start: 464, id: 16, no: 17 }, __clicksContext: null, __preloaded: !1 }), Ci = {}, Pt = E(Ci), Di = P({ get layout() { return Pt.layout }, get transition() { return Pt.transition }, get class() { return Pt.class }, get clicks() { return Pt.clicks }, get name() { return Pt.name }, get preload() { return Pt.preload }, slide: { content: "", revision: "3o7y9k", note: "", title: "Diagrams", level: 1, index: 17, noteHTML: "", raw: "", frontmatter: Pt, filepath: "", start: 486, id: 17, no: 18 }, __clicksContext: null, __preloaded: !1 }), Ii = {}, At = E(Ii), Ri = P({ get layout() { return At.layout }, get transition() { return At.transition }, get class() { return At.class }, get clicks() { return At.clicks }, get name() { return At.name }, get preload() { return At.preload }, slide: { content: "", revision: "wbypqk", note: "", index: 18, noteHTML: "", raw: "", frontmatter: At, filepath: "", start: 564, id: 18, no: 19 }, __clicksContext: null, __preloaded: !1 }), Ni = {}, Ct = E(Ni), ji = P({ get layout() { return Ct.layout }, get transition() { return Ct.transition }, get class() { return Ct.class }, get clicks() { return Ct.clicks }, get name() { return Ct.name }, get preload() { return Ct.preload }, slide: { content: "", revision: "-db6zcm", note: "", index: 19, noteHTML: "", raw: "", frontmatter: Ct, filepath: "", start: 569, id: 19, no: 20 }, __clicksContext: null, __preloaded: !1 }), Hi = {}, Dt = E(Hi), xi = P({ get layout() { return Dt.layout }, get transition() { return Dt.transition }, get class() { return Dt.class }, get clicks() { return Dt.clicks }, get name() { return Dt.name }, get preload() { return Dt.preload }, slide: { content: "", revision: "-db6zcm", note: "", index: 20, noteHTML: "", raw: "", frontmatter: Dt, filepath: "", start: 573, id: 20, no: 21 }, __clicksContext: null, __preloaded: !1 }), Vi = {}, It = E(Vi), Fi = P({ get layout() { return It.layout }, get transition() { return It.transition }, get class() { return It.class }, get clicks() { return It.clicks }, get name() { return It.name }, get preload() { return It.preload }, slide: { content: "", revision: "-db6zcm", note: "", index: 21, noteHTML: "", raw: "", frontmatter: It, filepath: "", start: 577, id: 21, no: 22 }, __clicksContext: null, __preloaded: !1 }), zi = {}, Rt = E(zi), Bi = P({ get layout() { return Rt.layout }, get transition() { return Rt.transition }, get class() { return Rt.class }, get clicks() { return Rt.clicks }, get name() { return Rt.name }, get preload() { return Rt.preload }, slide: { content: "", revision: "-db6zcm", note: "", index: 22, noteHTML: "", raw: "", frontmatter: Rt, filepath: "", start: 581, id: 22, no: 23 }, __clicksContext: null, __preloaded: !1 }), qi = {}, Nt = E(qi), Wi = P({ get layout() { return Nt.layout }, get transition() { return Nt.transition }, get class() { return Nt.class }, get clicks() { return Nt.clicks }, get name() { return Nt.name }, get preload() { return Nt.preload }, slide: { content: "", revision: "kplsec", note: "", index: 23, noteHTML: "", raw: "", frontmatter: Nt, filepath: "", start: 585, id: 23, no: 24 }, __clicksContext: null, __preloaded: !1 }), Ui = {}, jt = E(Ui), Ji = P({ get layout() { return jt.layout }, get transition() { return jt.transition }, get class() { return jt.class }, get clicks() { return jt.clicks }, get name() { return jt.name }, get preload() { return jt.preload }, slide: { content: "", revision: "-lfcxj6", note: "", index: 24, noteHTML: "", raw: "", frontmatter: jt, filepath: "", start: 589, id: 24, no: 25 }, __clicksContext: null, __preloaded: !1 }), Ki = {}, Ht = E(Ki), Gi = P({ get layout() { return Ht.layout }, get transition() { return Ht.transition }, get class() { return Ht.class }, get clicks() { return Ht.clicks }, get name() { return Ht.name }, get preload() { return Ht.preload }, slide: { content: "", revision: "8xx8a", note: "", title: "Draggable Elements", level: 1, index: 25, noteHTML: "", raw: "", frontmatter: Ht, filepath: "", start: 593, id: 25, no: 26 }, __clicksContext: null, __preloaded: !1 }), Qi = {}, xt = E(Qi), Yi = P({ get layout() { return xt.layout }, get transition() { return xt.transition }, get class() { return xt.class }, get clicks() { return xt.clicks }, get name() { return xt.name }, get preload() { return xt.preload }, slide: { content: "", revision: "-cpiein", note: "", index: 26, noteHTML: "", raw: "", frontmatter: xt, filepath: "", start: 634, id: 26, no: 27 }, __clicksContext: null, __preloaded: !1 }), Zi = {}, Vt = E(Zi), Xi = P({ get layout() { return Vt.layout }, get transition() { return Vt.transition }, get class() { return Vt.class }, get clicks() { return Vt.clicks }, get name() { return Vt.name }, get preload() { return Vt.preload }, slide: { content: "", revision: "0", note: "", index: 27, noteHTML: "", raw: "", frontmatter: Vt, filepath: "", start: 638, id: 27, no: 28 }, __clicksContext: null, __preloaded: !1 }), ta = {}, Ft = E(ta), ea = P({ get layout() { return Ft.layout }, get transition() { return Ft.transition }, get class() { return Ft.class }, get clicks() { return Ft.clicks }, get name() { return Ft.name }, get preload() { return Ft.preload }, slide: { content: "", revision: "-ui5wz4", note: "", title: "Monaco Editor", level: 1, index: 28, noteHTML: "", raw: "", frontmatter: Ft, filepath: "", start: 640, id: 28, no: 29 }, __clicksContext: null, __preloaded: !1 }), na = {}, zt = E(na), sa = P({ get layout() { return zt.layout }, get transition() { return zt.transition }, get class() { return zt.class }, get clicks() { return zt.clicks }, get name() { return zt.name }, get preload() { return zt.preload }, slide: { content: "", revision: "podzh8", note: "", index: 29, noteHTML: "", raw: "", frontmatter: zt, filepath: "", start: 666, id: 29, no: 30 }, __clicksContext: null, __preloaded: !1 }), ra = {}, Bt = E(ra), oa = P({ get layout() { return Bt.layout }, get transition() { return Bt.transition }, get class() { return Bt.class }, get clicks() { return Bt.clicks }, get name() { return Bt.name }, get preload() { return Bt.preload }, slide: { content: "", revision: "z4qekn", note: "", title: "Learn More", level: 1, index: 30, noteHTML: "", raw: "", frontmatter: Bt, filepath: "", start: 670, id: 30, no: 31 }, __clicksContext: null, __preloaded: !1 }), v = new Array(31), C = (n, t) => zr({ loader: t, delay: 300, loadingComponent: Yo, errorComponent: A, onError: e => console.error("Failed to load slide " + (n + 1), e) }), es = async () => { try { return v[0] ?? (v[0] = await $(() => import("./slidev/md-ClF0X0E-.js"), __vite__mapDeps([0, 1, 2, 3, 4, 5, 6, 7, 8]))) } catch (n) { return console.error("slide failed to load", n), A } }, ns = async () => { try { return v[1] ?? (v[1] = await $(() => import("./md-Bz5fzyVD.js"), __vite__mapDeps([9, 2, 10, 3, 4, 5, 6, 7, 8]))) } catch (n) { return console.error("slide failed to load", n), A } }, ss = async () => { try { return v[2] ?? (v[2] = await $(() => import("./md-DXR_J10G.js"), __vite__mapDeps([11, 2, 10, 3, 4, 5, 6, 7, 8, 12]))) } catch (n) { return console.error("slide failed to load", n), A } }, rs = async () => { try { return v[3] ?? (v[3] = await $(() => import("./md-DfC3lTnY.js"), __vite__mapDeps([13, 2, 10, 3, 4, 5, 6, 7, 8]))) } catch (n) { return console.error("slide failed to load", n), A } }, os = async () => { try { return v[4] ?? (v[4] = await $(() => import("./md-tSVJnXGJ.js"), __vite__mapDeps([14, 2, 10, 3, 4, 5, 6, 7, 8]))) } catch (n) { return console.error("slide failed to load", n), A } }, is = async () => { try { return v[5] ?? (v[5] = await $(() => import("./md-ClMJk-CZ.js"), __vite__mapDeps([15, 2, 10, 3, 4, 5, 6, 7, 8]))) } catch (n) { return console.error("slide failed to load", n), A } }, as = async () => { try { return v[6] ?? (v[6] = await $(() => import("./slidev/md-DCbXe0MZ.js"), __vite__mapDeps([16, 2, 3, 17, 4, 5, 6, 18, 1, 10, 7, 8, 19]))) } catch (n) { return console.error("slide failed to load", n), A } }, ls = async () => { try { return v[7] ?? (v[7] = await $(() => import("./md-BZ47sGWi.js"), __vite__mapDeps([20, 2, 10, 3, 4, 5, 6, 7, 8]))) } catch (n) { return console.error("slide failed to load", n), A } }, cs = async () => { try { return v[8] ?? (v[8] = await $(() => import("./md-Kk7YH67r.js"), __vite__mapDeps([21, 22, 2, 18, 1, 3, 4, 5, 6, 10, 7, 8, 23]))) } catch (n) { return console.error("slide failed to load", n), A } }, us = async () => { try { return v[9] ?? (v[9] = await $(() => import("./md-C38cacXh.js"), __vite__mapDeps([24, 2, 10, 3, 4, 5, 6, 7, 8]))) } catch (n) { return console.error("slide failed to load", n), A } }, fs = async () => { try { return v[10] ?? (v[10] = await $(() => import("./md-CgZ1jk1v.js"), __vite__mapDeps([25, 2, 4, 5, 6, 26, 3, 10, 7, 8, 27]))) } catch (n) { return console.error("slide failed to load", n), A } }, ds = async () => { try { return v[11] ?? (v[11] = await $(() => import("./slidev/md-v3iux9r6.js"), __vite__mapDeps([28, 2, 4, 5, 6, 18, 1, 3, 10, 7, 8, 29]))) } catch (n) { return console.error("slide failed to load", n), A } }, hs = async () => { try { return v[12] ?? (v[12] = await $(() => import("./md-Dgs6EzeQ.js"), __vite__mapDeps([30, 2, 10, 3, 4, 5, 6, 7, 8]))) } catch (n) { return console.error("slide failed to load", n), A } }, ps = async () => { try { return v[13] ?? (v[13] = await $(() => import("./md-DiSIfiz7.js"), __vite__mapDeps([31, 18, 1, 2, 3, 4, 5, 6, 10, 7, 8]))) } catch (n) { return console.error("slide failed to load", n), A } }, gs = async () => { try { return v[14] ?? (v[14] = await $(() => import("./slidev/md-C8mWdNCw.js"), __vite__mapDeps([32, 2, 4, 5, 6, 3, 18, 1, 10, 7, 8]))) } catch (n) { return console.error("slide failed to load", n), A } }, ms = async () => { try { return v[15] ?? (v[15] = await $(() => import("./md-C2rd2vpG.js"), __vite__mapDeps([33, 18, 1, 2, 3, 4, 5, 6, 10, 7, 8]))) } catch (n) { return console.error("slide failed to load", n), A } }, ys = async () => { try { return v[16] ?? (v[16] = await $(() => import("./slidev/md-CAUzu8Ki.js"), __vite__mapDeps([34, 2, 3, 10, 4, 5, 6, 7, 8]))) } catch (n) { return console.error("slide failed to load", n), A } }, _s = async () => { try { return v[17] ?? (v[17] = await $(() => import("./md-ZFnz3MWp.js").then(n => n.bz), __vite__mapDeps([35, 2, 4, 5, 6, 26, 10, 3]))) } catch (n) { return console.error("slide failed to load", n), A } }, vs = async () => { try { return v[18] ?? (v[18] = await $(() => import("./md-Dp083uOp.js"), __vite__mapDeps([36, 2, 10, 3, 4, 5, 6, 7, 8]))) } catch (n) { return console.error("slide failed to load", n), A } }, ks = async () => { try { return v[19] ?? (v[19] = await $(() => import("./md-CZXri9e8.js"), __vite__mapDeps([37, 2, 10, 3, 4, 5, 6, 7, 8]))) } catch (n) { return console.error("slide failed to load", n), A } }, ws = async () => { try { return v[20] ?? (v[20] = await $(() => import("./md-oUrpCq9S.js"), __vite__mapDeps([38, 2, 10, 3, 4, 5, 6, 7, 8]))) } catch (n) { return console.error("slide failed to load", n), A } }, bs = async () => { try { return v[21] ?? (v[21] = await $(() => import("./md-ucEVbFgb.js"), __vite__mapDeps([39, 2, 10, 3, 4, 5, 6, 7, 8]))) } catch (n) { return console.error("slide failed to load", n), A } }, Ss = async () => { try { return v[22] ?? (v[22] = await $(() => import("./md-w_foF71n.js"), __vite__mapDeps([40, 2, 10, 3, 4, 5, 6, 7, 8]))) } catch (n) { return console.error("slide failed to load", n), A } }, Ms = async () => { try { return v[23] ?? (v[23] = await $(() => import("./md-C0e9YJXa.js"), __vite__mapDeps([41, 2, 10, 3, 4, 5, 6, 7, 8]))) } catch (n) { return console.error("slide failed to load", n), A } }, Os = async () => { try { return v[24] ?? (v[24] = await $(() => import("./md-CtkpCW-j.js"), __vite__mapDeps([42, 2, 10, 3, 4, 5, 6, 7, 8]))) } catch (n) { return console.error("slide failed to load", n), A } }, $s = async () => { try { return v[25] ?? (v[25] = await $(() => import("./slidev/md-FX75wghA.js"), __vite__mapDeps([43, 2, 22, 18, 1, 3, 4, 5, 6, 10, 7, 8]))) } catch (n) { return console.error("slide failed to load", n), A } }, Ls = async () => { try { return v[26] ?? (v[26] = await $(() => import("./md-7jFczfCX.js"), __vite__mapDeps([44, 2, 10, 3, 4, 5, 6, 7, 8]))) } catch (n) { return console.error("slide failed to load", n), A } }, Es = async () => { try { return v[27] ?? (v[27] = await $(() => import("./md-BsbvjOIv.js"), __vite__mapDeps([45, 2, 10, 3, 4, 5, 6, 7, 8]))) } catch (n) { return console.error("slide failed to load", n), A } }, Ts = async () => { try { return v[28] ?? (v[28] = await $(() => import("./slidev/md-CZ3auH7d.js"), __vite__mapDeps([46, 4, 5, 2, 6, 26, 3, 10, 7, 8, 47]))) } catch (n) { return console.error("slide failed to load", n), A } }, Ps = async () => { try { return v[29] ?? (v[29] = await $(() => import("./md-CSdA9JEq.js"), __vite__mapDeps([48, 2, 10, 3, 4, 5, 6, 7, 8]))) } catch (n) { return console.error("slide failed to load", n), A } }, As = async () => { try { return v[30] ?? (v[30] = await $(() => import("./slidev/md-Brewg9zi.js"), __vite__mapDeps([49, 2, 10, 3, 4, 5, 6, 7, 8]))) } catch (n) { return console.error("slide failed to load", n), A } }, ia = [{ no: 1, meta: Xo, load: es, component: C(0, es) }, { no: 2, meta: ei, load: ns, component: C(1, ns) }, { no: 3, meta: si, load: ss, component: C(2, ss) }, { no: 4, meta: oi, load: rs, component: C(3, rs) }, { no: 5, meta: ai, load: os, component: C(4, os) }, { no: 6, meta: ci, load: is, component: C(5, is) }, { no: 7, meta: fi, load: as, component: C(6, as) }, { no: 8, meta: hi, load: ls, component: C(7, ls) }, { no: 9, meta: gi, load: cs, component: C(8, cs) }, { no: 10, meta: yi, load: us, component: C(9, us) }, { no: 11, meta: vi, load: fs, component: C(10, fs) }, { no: 12, meta: wi, load: ds, component: C(11, ds) }, { no: 13, meta: Si, load: hs, component: C(12, hs) }, { no: 14, meta: Oi, load: ps, component: C(13, ps) }, { no: 15, meta: Li, load: gs, component: C(14, gs) }, { no: 16, meta: Ti, load: ms, component: C(15, ms) }, { no: 17, meta: Ai, load: ys, component: C(16, ys) }, { no: 18, meta: Di, load: _s, component: C(17, _s) }, { no: 19, meta: Ri, load: vs, component: C(18, vs) }, { no: 20, meta: ji, load: ks, component: C(19, ks) }, { no: 21, meta: xi, load: ws, component: C(20, ws) }, { no: 22, meta: Fi, load: bs, component: C(21, bs) }, { no: 23, meta: Bi, load: Ss, component: C(22, Ss) }, { no: 24, meta: Wi, load: Ms, component: C(23, Ms) }, { no: 25, meta: Ji, load: Os, component: C(24, Os) }, { no: 26, meta: Gi, load: $s, component: C(25, $s) }, { no: 27, meta: Yi, load: Ls, component: C(26, Ls) }, { no: 28, meta: Xi, load: Es, component: C(27, Es) }, { no: 29, meta: ea, load: Ts, component: C(28, Ts) }, { no: 30, meta: sa, load: Ps, component: C(29, Ps) }, { no: 31, meta: oa, load: As, component: C(30, As) }], st = Pn(ia); function sr(n, t) { if (!t || t === "all" || t === "*") return Kn(1, n + 1); if (t === "none") return []; const e = []; for (const s of t.split(/[,;]/g)) if (!s.includes("-")) e.push(+s); else { const [r, o] = s.split("-", 2); e.push(...Kn(+r, o ? +o + 1 : n + 1)) } return uo(e).filter(s => s <= n).sort((s, r) => s - r) } const Ke = "$$slidev-clicks-context", Cn = "$$slidev-page", rr = "$$slidev-slide-element", aa = "$$slidev-slide-scale", la = "$$slidev-context", dc = "$$slidev-route", Dn = "$$slidev-render-context", ca = "$$slidev-fontmatter", ua = "$$slidev-slide-zoom", Pe = "slidev-vclick-target", ce = "slidev-vclick-hidden", ue = "slidev-vclick-fade", sn = "slidev-vclick-hidden-explicitly", rn = "slidev-vclick-current", on = "slidev-vclick-prior", Ae = 999999, fa = ["localhost", "127.0.0.1"], da = ["clicks", "clicksStart", "disabled", "hide", "hideInToc", "layout", "level", "preload", "routeAlias", "src", "title", "transition", "zoom", "dragPos", "lang"], hc = [...da, "theme", "titleTemplate", "info", "author", "keywords", "presenter", "browserExporter", "download", "exportFilename", "export", "highlighter", "lineNumbers", "monaco", "monacoTypesSource", "monacoTypesAdditionalPackages", "monacoRunAdditionalDeps", "remoteAssets", "selectable", "record", "colorSchema", "routerMode", "aspectRatio", "canvasWidth", "themeConfig", "favicon", "plantUmlServer", "fonts", "defaults", "drawings", "htmlAttrs", "mdc", "contextMenu", "wakeLock", "seoMeta"]; function ha(n, t, { mode: e = "replace" } = {}) { const s = Je(); return S({ get() { const r = s.currentRoute.value.query[n]; return r == null ? t : Array.isArray(r) ? r.filter(Boolean) : r }, set(r) { Gs(() => { (s.currentRoute.value.query[n] ?? (t == null ? void 0 : t.toString())) !== r.toString() && s[Br(e)]({ query: { ...s.currentRoute.value.query, [n]: `${r}` === t ? void 0 : r } }) }) } }) } function Ge(n) { return st.value.find(t => { var e; return t.no === +n || ((e = t.meta.slide) == null ? void 0 : e.frontmatter.routeAlias) === n }) } function Zt(n, t, e = !1) { var r; (typeof n == "number" || typeof n == "string") && (n = Ge(n)); const s = ((r = n.meta.slide) == null ? void 0 : r.frontmatter.routeAlias) ?? n.no; return e ? `/export/${s}` : t ? `/presenter/${s}` : `/${s}` } const pa = { "slide-left": "slide-left | slide-right", "slide-right": "slide-right | slide-left", "slide-up": "slide-up | slide-down", "slide-down": "slide-down | slide-up" }; function ga(n, t = !1) { if (!n || (typeof n == "string" && (n = { name: n }), !n.name)) return; let e = n.name.includes("|") ? n.name : pa[n.name] || n.name; if (e.includes("|")) { const [s, r] = e.split("|").map(o => o.trim()); e = t ? r : s } if (e) return { ...n, name: e } } function ma(n, t, e) { var r, o; let s = n > 0 ? (r = e == null ? void 0 : e.meta) == null ? void 0 : r.transition : (o = t == null ? void 0 : t.meta) == null ? void 0 : o.transition; return s || (s = J.transition || void 0), ga(s, n < 0) } const pc = D(!1), gc = D(!1), mc = D(!1), ya = D(!1), In = D(!1), yc = D(!1), _c = D(!0), vc = qr({ xs: 460, ...Qr }), xe = Wr(), kc = Ur(), wc = S(() => xe.height.value - xe.width.value / fo.value > 120), bc = Jr(An ? document.body : null), or = Kr(), Sc = S(() => { var n; return ["INPUT", "TEXTAREA"].includes(((n = or.value) == null ? void 0 : n.tagName) || "") }), Mc = S(() => { var n; return ["BUTTON", "A"].includes(((n = or.value) == null ? void 0 : n.tagName) || "") }); U("slidev-camera", "default", { listenToStorageChanges: !1 }); U("slidev-mic", "default", { listenToStorageChanges: !1 }); const _a = U("slidev-scale", 0), Oc = U("slidev-wake-lock", !0), $c = U("slidev-hide-cursor-idle", !0); U("slidev-skip-export-pdf-tip", !1); U("slidev-export-capture-delay", 400, { listenToStorageChanges: !1 }); const Lc = U("slidev-presenter-cursor", !0, { listenToStorageChanges: !1 }), va = U("slidev-show-editor", !1, { listenToStorageChanges: !1 }), ka = U("slidev-editor-vertical", !1, { listenToStorageChanges: !1 }), wa = U("slidev-editor-width", An ? window.innerWidth * .4 : 318, { listenToStorageChanges: !1 }), ba = U("slidev-editor-height", An ? window.innerHeight * .4 : 300, { listenToStorageChanges: !1 }), be = Pn(null), Ve = U("slidev-presenter-font-size", 1, { listenToStorageChanges: !1 }), Se = U("slidev-presenter-layout", 1, { listenToStorageChanges: !1 }), vn = { invert: !1, contrast: 1, brightness: 1, hueRotate: 0, saturate: 1, sepia: 0 }, Sa = U("slidev-viewer-css-filter", vn, { listenToStorageChanges: !1, mergeDefaults: !0, deep: !0 }), Ec = S(() => Object.keys(vn).some(n => Sa.value[n] !== vn[n])); function Tc() { Se.value = Se.value + 1, Se.value > 3 && (Se.value = 1) } function Pc() { Ve.value = Math.min(2, Ve.value + .1) } function Ac() { Ve.value = Math.max(.5, Ve.value - .1) } const Cc = Gr(ya), Me = U("slidev-sync-directions", { viewerSend: !0, viewerReceive: !0, presenterSend: !0, presenterReceive: !0 }, { listenToStorageChanges: !1, mergeDefaults: !0 }); function ir(n, t, e = 1) { var r, o, i, a, l, c, u; const s = t.meta.slide.level ?? e; s && s > e && n.length > 0 ? ir(n[n.length - 1].children, t, e + 1) : n.push({ no: t.no, children: [], level: e, titleLevel: s, path: Zt(((o = (r = t.meta.slide) == null ? void 0 : r.frontmatter) == null ? void 0 : o.routeAlias) ?? t.no, !1), hideInToc: !!((l = (a = (i = t.meta) == null ? void 0 : i.slide) == null ? void 0 : a.frontmatter) != null && l.hideInToc), title: (u = (c = t.meta) == null ? void 0 : c.slide) == null ? void 0 : u.title }) } function ar(n, t, e = !1, s, r) { return n.map(o => { const i = { ...o, active: o.no === (r == null ? void 0 : r.value), hasActiveParent: e }; return i.children.length > 0 && (i.children = ar(i.children, t, i.active || i.hasActiveParent, i, r)), s && (i.active || i.activeParent) && (s.activeParent = !0), i }) } function lr(n, t = 1) { return n.filter(e => !e.hideInToc).map(e => ({ ...e, children: lr(e.children, t + 1) })) } function Ma(n, t, e) { const s = S(() => n.value.filter(o => { var i, a; return (a = (i = o.meta) == null ? void 0 : i.slide) == null ? void 0 : a.title }).reduce((o, i) => (ir(o, i), o), [])), r = S(() => ar(s.value, e.value, void 0, void 0, t)); return S(() => lr(r.value)) } function Oa(n, t, e = D(0), s, r, o) { const i = S(() => st.value.length), a = D(0), l = D(0), c = S(() => Zt(n.value, s.value)), u = S(() => n.value.no), f = S(() => { var N; return ((N = n.value.meta) == null ? void 0 : N.layout) || (u.value === 1 ? "cover" : "default") }), g = S(() => t.value.current), h = S(() => t.value.clicksStart), p = S(() => t.value.total), d = S(() => st.value[Math.min(st.value.length, u.value + 1) - 1]), m = S(() => st.value[Math.max(1, u.value - 1) - 1]), _ = S(() => u.value < st.value.length || g.value < p.value), y = S(() => u.value > 1 || g.value > 0), k = S(() => r.value ? void 0 : ma(a.value, n.value, m.value)); ot(n, (N, j) => { a.value = N.no - j.no }); async function w(N) { return !1 } const b = Ma(st, u, n); async function O() { l.value = 1, p.value <= e.value ? await I() : e.value += 1 } async function L() { l.value = -1, e.value <= h.value ? await V(!0) : e.value -= 1 } async function I(N = !1) { l.value = 1, u.value < st.value.length && await T(u.value + 1, N && !r.value ? Ae : void 0) } async function V(N = !1) { l.value = -1, u.value > 1 && await T(u.value - 1, N && !r.value ? Ae : void 0) } function et() { return T(1) } function Z() { return T(i.value) } async function T(N, j = 0, at = !1) { var x, dt, ae; In.value = !1; const ct = u.value !== N, ie = j !== e.value, B = (x = Ge(N)) == null ? void 0 : x.meta, we = ((dt = B == null ? void 0 : B.slide) == null ? void 0 : dt.frontmatter.clicksStart) ?? 0; j = gn(j, we, ((ae = B == null ? void 0 : B.__clicksContext) == null ? void 0 : ae.total) ?? Ae), (at || ct || ie) && await (o == null ? void 0 : o.push({ path: Zt(N, s.value, o.currentRoute.value.name === "export"), query: { ...o.currentRoute.value.query, clicks: j === 0 ? void 0 : j.toString(), embedded: location.search.includes("embedded") ? "true" : void 0 } })) } function R() { o == null || o.push({ path: Zt(u.value, !0), query: { ...o.currentRoute.value.query } }) } function z() { o == null || o.push({ path: Zt(u.value, !1), query: { ...o.currentRoute.value.query } }) } return { slides: st, total: i, currentPath: c, currentSlideNo: u, currentPage: u, currentSlideRoute: n, currentLayout: f, currentTransition: k, clicksDirection: l, nextRoute: d, prevRoute: m, clicksContext: t, clicks: g, clicksStart: h, clicksTotal: p, hasNext: _, hasPrev: y, tocTree: b, navDirection: a, openInEditor: w, next: O, prev: L, go: T, goLast: Z, goFirst: et, nextSlide: I, prevSlide: V, enterPresenter: R, exitPresenter: z } } const $a = Qs(() => { const n = Je(), t = Yr(), e = S(() => (n.currentRoute.value.query, new URLSearchParams(location.search))), s = S(() => e.value.has("print") || t.name === "export"), r = D(e.value.get("print") === "clicks"), o = S(() => e.value.has("embedded")), i = S(() => t.name === "play"), a = S(() => t.name === "presenter"), l = S(() => t.name === "notes"), c = S(() => !a.value && (!J.remote || e.value.get("password") === J.remote)), u = S(() => !!t.params.no), f = S(() => { var y; return u.value ? ((y = Ge(t.params.no)) == null ? void 0 : y.no) ?? 1 : 1 }), g = S(() => st.value[f.value - 1]), h = D(sr(st.value.length, t.query.range)), p = ha("clicks", "0"), d = S(() => _(g.value)), m = S({ get() { let y = +(p.value || 0); return Number.isNaN(y) && (y = 0), y }, set(y) { In.value = !1, p.value = y.toString() } }); function _(y) { var b, O; if ((b = y == null ? void 0 : y.meta) != null && b.__clicksContext) return y.meta.__clicksContext; const k = y.no, w = nr(S({ get() { return f.value === k ? Math.max(+(p.value ?? 0), w.clicksStart) : f.value > k ? Ae : w.clicksStart }, set(L) { f.value === k && (p.value = L.toString()) } }), ((O = y == null ? void 0 : y.meta.slide) == null ? void 0 : O.frontmatter.clicksStart) ?? 0, y == null ? void 0 : y.meta.clicks); return y != null && y.meta && (y.meta.__clicksContext = w), w } return { router: n, currentRoute: S(() => t), isPrintMode: s, isPrintWithClicks: r, isEmbedded: o, isPlaying: i, isPresenter: a, isNotesViewer: l, isPresenterAvailable: c, hasPrimarySlide: u, currentSlideNo: f, currentSlideRoute: g, clicksContext: d, queryClicksRaw: p, queryClicks: m, printRange: h, getPrimaryClicks: _ } }), re = Qs(() => { const n = $a(), t = Je(), e = Oa(n.currentSlideRoute, n.clicksContext, n.queryClicks, n.isPresenter, n.isPrintMode, t); return ot([e.total, n.currentRoute], async () => { const s = n.currentRoute.value.params.no; n.hasPrimarySlide.value && !Ge(s) && (s && s !== "index.html" ? await e.go(e.total.value, 0, !0) : await e.go(1, 0, !0)) }, { flush: "pre", immediate: !0 }), { ...e, ...n } }); function La() {
  const { isPrintMode: n } = re(); Zr(S(() => n.value ? `
@page {
  size: ${ho.value}px ${po.value}px;
  margin: 0px;
}

* {
  transition: none !important;
  transition-duration: 0s !important;
}`: ""))
} const Rn = Symbol.for("yaml.alias"), Ea = Symbol.for("yaml.document"), Jt = Symbol.for("yaml.map"), cr = Symbol.for("yaml.pair"), Nn = Symbol.for("yaml.scalar"), ve = Symbol.for("yaml.seq"), it = Symbol.for("yaml.node.type"), oe = n => !!n && typeof n == "object" && n[it] === Rn, Qe = n => !!n && typeof n == "object" && n[it] === Ea, ur = n => !!n && typeof n == "object" && n[it] === Jt, q = n => !!n && typeof n == "object" && n[it] === cr, F = n => !!n && typeof n == "object" && n[it] === Nn, jn = n => !!n && typeof n == "object" && n[it] === ve; function Y(n) { if (n && typeof n == "object") switch (n[it]) { case Jt: case ve: return !0 }return !1 } function W(n) { if (n && typeof n == "object") switch (n[it]) { case Rn: case Jt: case Nn: case ve: return !0 }return !1 } const Ta = n => (F(n) || Y(n)) && !!n.anchor, qt = Symbol("break visit"), Pa = Symbol("skip children"), pe = Symbol("remove node"); function ye(n, t) { const e = Aa(t); Qe(n) ? Xt(null, n.contents, e, Object.freeze([n])) === pe && (n.contents = null) : Xt(null, n, e, Object.freeze([])) } ye.BREAK = qt; ye.SKIP = Pa; ye.REMOVE = pe; function Xt(n, t, e, s) { const r = Ca(n, t, e, s); if (W(r) || q(r)) return Da(n, s, r), Xt(n, r, e, s); if (typeof r != "symbol") { if (Y(t)) { s = Object.freeze(s.concat(t)); for (let o = 0; o < t.items.length; ++o) { const i = Xt(o, t.items[o], e, s); if (typeof i == "number") o = i - 1; else { if (i === qt) return qt; i === pe && (t.items.splice(o, 1), o -= 1) } } } else if (q(t)) { s = Object.freeze(s.concat(t)); const o = Xt("key", t.key, e, s); if (o === qt) return qt; o === pe && (t.key = null); const i = Xt("value", t.value, e, s); if (i === qt) return qt; i === pe && (t.value = null) } } return r } function Aa(n) { return typeof n == "object" && (n.Collection || n.Node || n.Value) ? Object.assign({ Alias: n.Node, Map: n.Node, Scalar: n.Node, Seq: n.Node }, n.Value && { Map: n.Value, Scalar: n.Value, Seq: n.Value }, n.Collection && { Map: n.Collection, Seq: n.Collection }, n) : n } function Ca(n, t, e, s) { var r, o, i, a, l; if (typeof e == "function") return e(n, t, s); if (ur(t)) return (r = e.Map) == null ? void 0 : r.call(e, n, t, s); if (jn(t)) return (o = e.Seq) == null ? void 0 : o.call(e, n, t, s); if (q(t)) return (i = e.Pair) == null ? void 0 : i.call(e, n, t, s); if (F(t)) return (a = e.Scalar) == null ? void 0 : a.call(e, n, t, s); if (oe(t)) return (l = e.Alias) == null ? void 0 : l.call(e, n, t, s) } function Da(n, t, e) { const s = t[t.length - 1]; if (Y(s)) s.items[n] = e; else if (q(s)) n === "key" ? s.key = e : s.value = e; else if (Qe(s)) s.contents = e; else { const r = oe(s) ? "alias" : "scalar"; throw new Error(`Cannot replace node with ${r} parent`) } } function fr(n) { if (/[\x00-\x19\s,[\]{}]/.test(n)) { const e = `Anchor must not contain whitespace or control characters: ${JSON.stringify(n)}`; throw new Error(e) } return !0 } function he(n, t, e, s) { if (s && typeof s == "object") if (Array.isArray(s)) for (let r = 0, o = s.length; r < o; ++r) { const i = s[r], a = he(n, s, String(r), i); a === void 0 ? delete s[r] : a !== i && (s[r] = a) } else if (s instanceof Map) for (const r of Array.from(s.keys())) { const o = s.get(r), i = he(n, s, r, o); i === void 0 ? s.delete(r) : i !== o && s.set(r, i) } else if (s instanceof Set) for (const r of Array.from(s)) { const o = he(n, s, r, r); o === void 0 ? s.delete(r) : o !== r && (s.delete(r), s.add(o)) } else for (const [r, o] of Object.entries(s)) { const i = he(n, s, r, o); i === void 0 ? delete s[r] : i !== o && (s[r] = i) } return n.call(t, e, s) } function rt(n, t, e) { if (Array.isArray(n)) return n.map((s, r) => rt(s, String(r), e)); if (n && typeof n.toJSON == "function") { if (!e || !Ta(n)) return n.toJSON(t, e); const s = { aliasCount: 0, count: 1, res: void 0 }; e.anchors.set(n, s), e.onCreate = o => { s.res = o, delete e.onCreate }; const r = n.toJSON(t, e); return e.onCreate && e.onCreate(r), r } return typeof n == "bigint" && !(e != null && e.keep) ? Number(n) : n } class Hn { constructor(t) { Object.defineProperty(this, it, { value: t }) } clone() { const t = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this)); return this.range && (t.range = this.range.slice()), t } toJS(t, { mapAsMap: e, maxAliasCount: s, onAnchor: r, reviver: o } = {}) { if (!Qe(t)) throw new TypeError("A document argument is required"); const i = { anchors: new Map, doc: t, keep: !0, mapAsMap: e === !0, mapKeyWarned: !1, maxAliasCount: typeof s == "number" ? s : 100 }, a = rt(this, "", i); if (typeof r == "function") for (const { count: l, res: c } of i.anchors.values()) r(c, l); return typeof o == "function" ? he(o, { "": a }, "", a) : a } } class Ia extends Hn { constructor(t) { super(Rn), this.source = t, Object.defineProperty(this, "tag", { set() { throw new Error("Alias nodes cannot have tags") } }) } resolve(t) { let e; return ye(t, { Node: (s, r) => { if (r === this) return ye.BREAK; r.anchor === this.source && (e = r) } }), e } toJSON(t, e) { if (!e) return { source: this.source }; const { anchors: s, doc: r, maxAliasCount: o } = e, i = this.resolve(r); if (!i) { const l = `Unresolved alias (the anchor must be set before the alias): ${this.source}`; throw new ReferenceError(l) } let a = s.get(i); if (a || (rt(i, null, e), a = s.get(i)), !a || a.res === void 0) { const l = "This should not happen: Alias anchor was not resolved?"; throw new ReferenceError(l) } if (o >= 0 && (a.count += 1, a.aliasCount === 0 && (a.aliasCount = Ce(r, i, s)), a.count * a.aliasCount > o)) { const l = "Excessive alias count indicates a resource exhaustion attack"; throw new ReferenceError(l) } return a.res } toString(t, e, s) { const r = `*${this.source}`; if (t) { if (fr(this.source), t.options.verifyAliasOrder && !t.anchors.has(this.source)) { const o = `Unresolved alias (the anchor must be set before the alias): ${this.source}`; throw new Error(o) } if (t.implicitKey) return `${r} ` } return r } } function Ce(n, t, e) { if (oe(t)) { const s = t.resolve(n), r = e && s && e.get(s); return r ? r.count * r.aliasCount : 0 } else if (Y(t)) { let s = 0; for (const r of t.items) { const o = Ce(n, r, e); o > s && (s = o) } return s } else if (q(t)) { const s = Ce(n, t.key, e), r = Ce(n, t.value, e); return Math.max(s, r) } return 1 } const dr = n => !n || typeof n != "function" && typeof n != "object"; class H extends Hn { constructor(t) { super(Nn), this.value = t } toJSON(t, e) { return e != null && e.keep ? this.value : rt(this.value, t, e) } toString() { return String(this.value) } } H.BLOCK_FOLDED = "BLOCK_FOLDED"; H.BLOCK_LITERAL = "BLOCK_LITERAL"; H.PLAIN = "PLAIN"; H.QUOTE_DOUBLE = "QUOTE_DOUBLE"; H.QUOTE_SINGLE = "QUOTE_SINGLE"; function Ra(n, t, e) { return e.find(s => { var r; return ((r = s.identify) == null ? void 0 : r.call(s, n)) && !s.format }) } function Fe(n, t, e) { var f, g, h; if (Qe(n) && (n = n.contents), W(n)) return n; if (q(n)) { const p = (g = (f = e.schema[Jt]).createNode) == null ? void 0 : g.call(f, e.schema, null, e); return p.items.push(n), p } (n instanceof String || n instanceof Number || n instanceof Boolean || typeof BigInt < "u" && n instanceof BigInt) && (n = n.valueOf()); const { aliasDuplicateObjects: s, onAnchor: r, onTagObj: o, schema: i, sourceObjects: a } = e; let l; if (s && n && typeof n == "object") { if (l = a.get(n), l) return l.anchor || (l.anchor = r(n)), new Ia(l.anchor); l = { anchor: null, node: null }, a.set(n, l) } let c = Ra(n, t, i.tags); if (!c) { if (n && typeof n.toJSON == "function" && (n = n.toJSON()), !n || typeof n != "object") { const p = new H(n); return l && (l.node = p), p } c = n instanceof Map ? i[Jt] : Symbol.iterator in Object(n) ? i[ve] : i[Jt] } o && (o(c), delete e.onTagObj); const u = c != null && c.createNode ? c.createNode(e.schema, n, e) : typeof ((h = c == null ? void 0 : c.nodeClass) == null ? void 0 : h.from) == "function" ? c.nodeClass.from(e.schema, n, e) : new H(n); return c.default || (u.tag = c.tag), l && (l.node = u), u } function Cs(n, t, e) { let s = e; for (let r = t.length - 1; r >= 0; --r) { const o = t[r]; if (typeof o == "number" && Number.isInteger(o) && o >= 0) { const i = []; i[o] = s, s = i } else s = new Map([[o, s]]) } return Fe(s, void 0, { aliasDuplicateObjects: !1, keepUndefined: !1, onAnchor: () => { throw new Error("This should not happen, please report a bug.") }, schema: n, sourceObjects: new Map }) } const Na = n => n == null || typeof n == "object" && !!n[Symbol.iterator]().next().done; class hr extends Hn { constructor(t, e) { super(t), Object.defineProperty(this, "schema", { value: e, configurable: !0, enumerable: !1, writable: !0 }) } clone(t) { const e = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this)); return t && (e.schema = t), e.items = e.items.map(s => W(s) || q(s) ? s.clone(t) : s), this.range && (e.range = this.range.slice()), e } addIn(t, e) { if (Na(t)) this.add(e); else { const [s, ...r] = t, o = this.get(s, !0); if (Y(o)) o.addIn(r, e); else if (o === void 0 && this.schema) this.set(s, Cs(this.schema, r, e)); else throw new Error(`Expected YAML collection at ${s}. Remaining path: ${r}`) } } deleteIn(t) { const [e, ...s] = t; if (s.length === 0) return this.delete(e); const r = this.get(e, !0); if (Y(r)) return r.deleteIn(s); throw new Error(`Expected YAML collection at ${e}. Remaining path: ${s}`) } getIn(t, e) { const [s, ...r] = t, o = this.get(s, !0); return r.length === 0 ? !e && F(o) ? o.value : o : Y(o) ? o.getIn(r, e) : void 0 } hasAllNullValues(t) { return this.items.every(e => { if (!q(e)) return !1; const s = e.value; return s == null || t && F(s) && s.value == null && !s.commentBefore && !s.comment && !s.tag }) } hasIn(t) { const [e, ...s] = t; if (s.length === 0) return this.has(e); const r = this.get(e, !0); return Y(r) ? r.hasIn(s) : !1 } setIn(t, e) { const [s, ...r] = t; if (r.length === 0) this.set(s, e); else { const o = this.get(s, !0); if (Y(o)) o.setIn(r, e); else if (o === void 0 && this.schema) this.set(s, Cs(this.schema, r, e)); else throw new Error(`Expected YAML collection at ${s}. Remaining path: ${r}`) } } } const ja = n => n.replace(/^(?!$)(?: $)?/gm, "#"); function _e(n, t) { return /^\n+$/.test(n) ? n.substring(1) : t ? n.replace(/^(?! *$)/gm, t) : n } const te = (n, t, e) => n.endsWith(`
`) ? _e(e, t) : e.includes(`
`) ? `
`+ _e(e, t) : (n.endsWith(" ") ? "" : " ") + e, pr = "flow", kn = "block", De = "quoted"; function Ye(n, t, e = "flow", { indentAtStart: s, lineWidth: r = 80, minContentWidth: o = 20, onFold: i, onOverflow: a } = {}) {
  if (!r || r < 0) return n; r < o && (o = 0); const l = Math.max(1 + o, 1 + r - t.length); if (n.length <= l) return n; const c = [], u = {}; let f = r - t.length; typeof s == "number" && (s > r - Math.max(2, o) ? c.push(0) : f = r - s); let g, h, p = !1, d = -1, m = -1, _ = -1; e === kn && (d = Ds(n, d, t.length), d !== -1 && (f = d + l)); for (let k; k = n[d += 1];) {
    if (e === De && k === "\\") { switch (m = d, n[d + 1]) { case "x": d += 3; break; case "u": d += 5; break; case "U": d += 9; break; default: d += 1 }_ = d } if (k === `
`) e === kn && (d = Ds(n, d, t.length)), f = d + t.length + l, g = void 0; else {
      if (k === " " && h && h !== " " && h !== `
`&& h !== "	") {
        const w = n[d + 1]; w && w !== " " && w !== `
`&& w !== "	" && (g = d)
      } if (d >= f) if (g) c.push(g), f = g + l, g = void 0; else if (e === De) { for (; h === " " || h === "	";)h = k, k = n[d += 1], p = !0; const w = d > _ + 1 ? d - 2 : m - 1; if (u[w]) return n; c.push(w), u[w] = !0, f = w + l, g = void 0 } else p = !0
    } h = k
  } if (p && a && a(), c.length === 0) return n; i && i(); let y = n.slice(0, c[0]); for (let k = 0; k < c.length; ++k) {
    const w = c[k], b = c[k + 1] || n.length; w === 0 ? y = `
${t}${n.slice(0, b)}` : (e === De && u[w] && (y += `${n[w]}\\`), y += `
${t}${n.slice(w + 1, b)}`)
  } return y
} function Ds(n, t, e) {
  let s = t, r = t + 1, o = n[r]; for (; o === " " || o === "	";)if (t < r + e) o = n[++t]; else {
    do o = n[++t]; while (o && o !== `
`); s = t, r = t + 1, o = n[r]
  } return s
} const Ze = (n, t) => ({ indentAtStart: t ? n.indent.length : n.indentAtStart, lineWidth: n.options.lineWidth, minContentWidth: n.options.minContentWidth }), Xe = n => /^(%|---|\.\.\.)/m.test(n); function Ha(n, t, e) {
  if (!t || t < 0) return !1; const s = t - e, r = n.length; if (r <= s) return !1; for (let o = 0, i = 0; o < r; ++o)if (n[o] === `
`) { if (o - i > s) return !0; if (i = o + 1, r - i <= s) return !1 } return !0
} function ge(n, t) {
  const e = JSON.stringify(n); if (t.options.doubleQuotedAsJSON) return e; const { implicitKey: s } = t, r = t.options.doubleQuotedMinMultiLineLength, o = t.indent || (Xe(n) ? "  " : ""); let i = "", a = 0; for (let l = 0, c = e[l]; c; c = e[++l])if (c === " " && e[l + 1] === "\\" && e[l + 2] === "n" && (i += e.slice(a, l) + "\\ ", l += 1, a = l, c = "\\"), c === "\\") switch (e[l + 1]) {
    case "u": { i += e.slice(a, l); const u = e.substr(l + 2, 4); switch (u) { case "0000": i += "\\0"; break; case "0007": i += "\\a"; break; case "000b": i += "\\v"; break; case "001b": i += "\\e"; break; case "0085": i += "\\N"; break; case "00a0": i += "\\_"; break; case "2028": i += "\\L"; break; case "2029": i += "\\P"; break; default: u.substr(0, 2) === "00" ? i += "\\x" + u.substr(2) : i += e.substr(l, 6) }l += 5, a = l + 1 } break; case "n": if (s || e[l + 2] === '"' || e.length < r) l += 1; else {
      for (i += e.slice(a, l) + `

`; e[l + 2] === "\\" && e[l + 3] === "n" && e[l + 4] !== '"';)i += `
`, l += 2; i += o, e[l + 2] === " " && (i += "\\"), l += 1, a = l + 1
    } break; default: l += 1
  }return i = a ? i + e.slice(a) : e, s ? i : Ye(i, o, De, Ze(t, !1))
} function wn(n, t) {
  if (t.options.singleQuote === !1 || t.implicitKey && n.includes(`
`) || /[ \t]\n|\n[ \t]/.test(n)) return ge(n, t); const e = t.indent || (Xe(n) ? "  " : ""), s = "'" + n.replace(/'/g, "''").replace(/\n+/g, `$&
${e}`) + "'"; return t.implicitKey ? s : Ye(s, e, pr, Ze(t, !1))
} function ee(n, t) { const { singleQuote: e } = t.options; let s; if (e === !1) s = ge; else { const r = n.includes('"'), o = n.includes("'"); r && !o ? s = wn : o && !r ? s = ge : s = e ? wn : ge } return s(n, t) } let bn; try {
  bn = new RegExp(`(^|(?<!
))
+(?!
|$)`, "g")
} catch { bn = /\n+(?!\n|$)/g } function Ie({ comment: n, type: t, value: e }, s, r, o) {
  const { blockQuote: i, commentString: a, lineWidth: l } = s.options; if (!i || /\n[\t ]+$/.test(e) || /^\s*$/.test(e)) return ee(e, s); const c = s.indent || (s.forceBlockIndent || Xe(e) ? "  " : ""), u = i === "literal" ? !0 : i === "folded" || t === H.BLOCK_FOLDED ? !1 : t === H.BLOCK_LITERAL ? !0 : !Ha(e, l, c.length); if (!e) return u ? `|
`: `>
`; let f, g; for (g = e.length; g > 0; --g) {
    const b = e[g - 1]; if (b !== `
`&& b !== "	" && b !== " ") break
  } let h = e.substring(g); const p = h.indexOf(`
`); p === -1 ? f = "-" : e === h || p !== h.length - 1 ? (f = "+", o && o()) : f = "", h && (e = e.slice(0, -h.length), h[h.length - 1] === `
`&& (h = h.slice(0, -1)), h = h.replace(bn, `$&${c}`)); let d = !1, m, _ = -1; for (m = 0; m < e.length; ++m) {
    const b = e[m]; if (b === " ") d = !0; else if (b === `
`) _ = m; else break
  } let y = e.substring(0, _ < m ? _ + 1 : m); y && (e = e.substring(y.length), y = y.replace(/\n+/g, `$&${c}`)); let w = (d ? c ? "2" : "1" : "") + f; if (n && (w += " " + a(n.replace(/ ?[\r\n]+/g, " ")), r && r()), !u) {
    const b = e.replace(/\n+/g, `
$&`).replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${c}`); let O = !1; const L = Ze(s, !0); i !== "folded" && t !== H.BLOCK_FOLDED && (L.onOverflow = () => { O = !0 }); const I = Ye(`${y}${b}${h}`, c, kn, L); if (!O) return `>${w}
${c}${I}`
  } return e = e.replace(/\n+/g, `$&${c}`), `|${w}
${c}${y}${e}${h}`
} function xa(n, t, e, s) {
  const { type: r, value: o } = n, { actualString: i, implicitKey: a, indent: l, indentStep: c, inFlow: u } = t; if (a && o.includes(`
`) || u && /[[\]{},]/.test(o)) return ee(o, t); if (!o || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(o)) return a || u || !o.includes(`
`) ? ee(o, t) : Ie(n, t, e, s); if (!a && !u && r !== H.PLAIN && o.includes(`
`)) return Ie(n, t, e, s); if (Xe(o)) { if (l === "") return t.forceBlockIndent = !0, Ie(n, t, e, s); if (a && l === c) return ee(o, t) } const f = o.replace(/\n+/g, `$&
${l}`); if (i) { const g = d => { var m; return d.default && d.tag !== "tag:yaml.org,2002:str" && ((m = d.test) == null ? void 0 : m.test(f)) }, { compat: h, tags: p } = t.doc.schema; if (p.some(g) || h != null && h.some(g)) return ee(o, t) } return a ? f : Ye(f, l, pr, Ze(t, !1))
} function Va(n, t, e, s) { const { implicitKey: r, inFlow: o } = t, i = typeof n.value == "string" ? n : Object.assign({}, n, { value: String(n.value) }); let { type: a } = n; a !== H.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(i.value) && (a = H.QUOTE_DOUBLE); const l = u => { switch (u) { case H.BLOCK_FOLDED: case H.BLOCK_LITERAL: return r || o ? ee(i.value, t) : Ie(i, t, e, s); case H.QUOTE_DOUBLE: return ge(i.value, t); case H.QUOTE_SINGLE: return wn(i.value, t); case H.PLAIN: return xa(i, t, e, s); default: return null } }; let c = l(a); if (c === null) { const { defaultKeyType: u, defaultStringType: f } = t.options, g = r && u || f; if (c = l(g), c === null) throw new Error(`Unsupported default string type ${g}`) } return c } function Fa(n, t) { const e = Object.assign({ blockQuote: !0, commentString: ja, defaultKeyType: null, defaultStringType: "PLAIN", directives: null, doubleQuotedAsJSON: !1, doubleQuotedMinMultiLineLength: 40, falseStr: "false", flowCollectionPadding: !0, indentSeq: !0, lineWidth: 80, minContentWidth: 20, nullStr: "null", simpleKeys: !1, singleQuote: null, trueStr: "true", verifyAliasOrder: !0 }, n.schema.toStringOptions, t); let s; switch (e.collectionStyle) { case "block": s = !1; break; case "flow": s = !0; break; default: s = null }return { anchors: new Set, doc: n, flowCollectionPadding: e.flowCollectionPadding ? " " : "", indent: "", indentStep: typeof e.indent == "number" ? " ".repeat(e.indent) : "  ", inFlow: s, options: e } } function za(n, t) { var r; if (t.tag) { const o = n.filter(i => i.tag === t.tag); if (o.length > 0) return o.find(i => i.format === t.format) ?? o[0] } let e, s; if (F(t)) { s = t.value; let o = n.filter(i => { var a; return (a = i.identify) == null ? void 0 : a.call(i, s) }); if (o.length > 1) { const i = o.filter(a => a.test); i.length > 0 && (o = i) } e = o.find(i => i.format === t.format) ?? o.find(i => !i.format) } else s = t, e = n.find(o => o.nodeClass && s instanceof o.nodeClass); if (!e) { const o = ((r = s == null ? void 0 : s.constructor) == null ? void 0 : r.name) ?? typeof s; throw new Error(`Tag not resolved for ${o} value`) } return e } function Ba(n, t, { anchors: e, doc: s }) { if (!s.directives) return ""; const r = [], o = (F(n) || Y(n)) && n.anchor; o && fr(o) && (e.add(o), r.push(`&${o}`)); const i = n.tag ? n.tag : t.default ? null : t.tag; return i && r.push(s.directives.tagString(i)), r.join(" ") } function ze(n, t, e, s) {
  var l; if (q(n)) return n.toString(t, e, s); if (oe(n)) { if (t.doc.directives) return n.toString(t); if ((l = t.resolvedAliases) != null && l.has(n)) throw new TypeError("Cannot stringify circular structure without alias nodes"); t.resolvedAliases ? t.resolvedAliases.add(n) : t.resolvedAliases = new Set([n]), n = n.resolve(t.doc) } let r; const o = W(n) ? n : t.doc.createNode(n, { onTagObj: c => r = c }); r || (r = za(t.doc.schema.tags, o)); const i = Ba(o, r, t); i.length > 0 && (t.indentAtStart = (t.indentAtStart ?? 0) + i.length + 1); const a = typeof r.stringify == "function" ? r.stringify(o, t, e, s) : F(o) ? Va(o, t, e, s) : o.toString(t, e, s); return i ? F(o) || a[0] === "{" || a[0] === "[" ? `${i} ${a}` : `${i}
${t.indent}${a}` : a
} function qa({ key: n, value: t }, e, s, r) {
  const { allNullValues: o, doc: i, indent: a, indentStep: l, options: { commentString: c, indentSeq: u, simpleKeys: f } } = e; let g = W(n) && n.comment || null; if (f) { if (g) throw new Error("With simple keys, key nodes cannot have comments"); if (Y(n) || !W(n) && typeof n == "object") { const L = "With simple keys, collection cannot be used as a key value"; throw new Error(L) } } let h = !f && (!n || g && t == null && !e.inFlow || Y(n) || (F(n) ? n.type === H.BLOCK_FOLDED || n.type === H.BLOCK_LITERAL : typeof n == "object")); e = Object.assign({}, e, { allNullValues: !1, implicitKey: !h && (f || !o), indent: a + l }); let p = !1, d = !1, m = ze(n, e, () => p = !0, () => d = !0); if (!h && !e.inFlow && m.length > 1024) { if (f) throw new Error("With simple keys, single line scalar must not span more than 1024 characters"); h = !0 } if (e.inFlow) { if (o || t == null) return p && s && s(), m === "" ? "?" : h ? `? ${m}` : m } else if (o && !f || t == null && h) return m = `? ${m}`, g && !p ? m += te(m, e.indent, c(g)) : d && r && r(), m; p && (g = null), h ? (g && (m += te(m, e.indent, c(g))), m = `? ${m}
${a}:`) : (m = `${m}:`, g && (m += te(m, e.indent, c(g)))); let _, y, k; W(t) ? (_ = !!t.spaceBefore, y = t.commentBefore, k = t.comment) : (_ = !1, y = null, k = null, t && typeof t == "object" && (t = i.createNode(t))), e.implicitKey = !1, !h && !g && F(t) && (e.indentAtStart = m.length + 1), d = !1, !u && l.length >= 2 && !e.inFlow && !h && jn(t) && !t.flow && !t.tag && !t.anchor && (e.indent = e.indent.substring(2)); let w = !1; const b = ze(t, e, () => w = !0, () => d = !0); let O = " "; if (g || _ || y) {
    if (O = _ ? `
`: "", y) {
      const L = c(y); O += `
${_e(L, e.indent)}`
    } b === "" && !e.inFlow ? O === `
`&& (O = `

`) : O += `
${e.indent}`
  } else if (!h && Y(t)) {
    const L = b[0], I = b.indexOf(`
`), V = I !== -1, et = e.inFlow ?? t.flow ?? t.items.length === 0; if (V || !et) {
      let Z = !1; if (V && (L === "&" || L === "!")) { let T = b.indexOf(" "); L === "&" && T !== -1 && T < I && b[T + 1] === "!" && (T = b.indexOf(" ", T + 1)), (T === -1 || I < T) && (Z = !0) } Z || (O = `
${e.indent}`)
    }
  } else (b === "" || b[0] === `
`) && (O = ""); return m += O + b, e.inFlow ? w && s && s() : k && !w ? m += te(m, e.indent, c(k)) : d && r && r(), m
} function Wa(n, t) { (n === "debug" || n === "warn") && console.warn(t) } const Oe = "<<", an = { identify: n => n === Oe || typeof n == "symbol" && n.description === Oe, default: "key", tag: "tag:yaml.org,2002:merge", test: /^<<$/, resolve: () => Object.assign(new H(Symbol(Oe)), { addToJSMap: gr }), stringify: () => Oe }, Ua = (n, t) => (an.identify(t) || F(t) && (!t.type || t.type === H.PLAIN) && an.identify(t.value)) && (n == null ? void 0 : n.doc.schema.tags.some(e => e.tag === an.tag && e.default)); function gr(n, t, e) { if (e = n && oe(e) ? e.resolve(n.doc) : e, jn(e)) for (const s of e.items) ln(n, t, s); else if (Array.isArray(e)) for (const s of e) ln(n, t, s); else ln(n, t, e) } function ln(n, t, e) { const s = n && oe(e) ? e.resolve(n.doc) : e; if (!ur(s)) throw new Error("Merge sources must be maps or map aliases"); const r = s.toJSON(null, n, Map); for (const [o, i] of r) t instanceof Map ? t.has(o) || t.set(o, i) : t instanceof Set ? t.add(o) : Object.prototype.hasOwnProperty.call(t, o) || Object.defineProperty(t, o, { value: i, writable: !0, enumerable: !0, configurable: !0 }); return t } function mr(n, t, { key: e, value: s }) { if (W(e) && e.addToJSMap) e.addToJSMap(n, t, s); else if (Ua(n, e)) gr(n, t, s); else { const r = rt(e, "", n); if (t instanceof Map) t.set(r, rt(s, r, n)); else if (t instanceof Set) t.add(r); else { const o = Ja(e, r, n), i = rt(s, o, n); o in t ? Object.defineProperty(t, o, { value: i, writable: !0, enumerable: !0, configurable: !0 }) : t[o] = i } } return t } function Ja(n, t, e) { if (t === null) return ""; if (typeof t != "object") return String(t); if (W(n) && (e != null && e.doc)) { const s = Fa(e.doc, {}); s.anchors = new Set; for (const o of e.anchors.keys()) s.anchors.add(o.anchor); s.inFlow = !0, s.inStringifyKey = !0; const r = n.toString(s); if (!e.mapKeyWarned) { let o = JSON.stringify(r); o.length > 40 && (o = o.substring(0, 36) + '..."'), Wa(e.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${o}. Set mapAsMap: true to use object keys.`), e.mapKeyWarned = !0 } return r } return JSON.stringify(t) } function xn(n, t, e) { const s = Fe(n, void 0, e), r = Fe(t, void 0, e); return new lt(s, r) } class lt { constructor(t, e = null) { Object.defineProperty(this, it, { value: cr }), this.key = t, this.value = e } clone(t) { let { key: e, value: s } = this; return W(e) && (e = e.clone(t)), W(s) && (s = s.clone(t)), new lt(e, s) } toJSON(t, e) { const s = e != null && e.mapAsMap ? new Map : {}; return mr(e, s, this) } toString(t, e, s) { return t != null && t.doc ? qa(this, t, e, s) : JSON.stringify(this) } } function yr(n, t, e) { return (t.inFlow ?? n.flow ? Ga : Ka)(n, t, e) } function Ka({ comment: n, items: t }, e, { blockItemPrefix: s, flowChars: r, itemIndent: o, onChompKeep: i, onComment: a }) {
  const { indent: l, options: { commentString: c } } = e, u = Object.assign({}, e, { indent: o, type: null }); let f = !1; const g = []; for (let p = 0; p < t.length; ++p) { const d = t[p]; let m = null; if (W(d)) !f && d.spaceBefore && g.push(""), Be(e, g, d.commentBefore, f), d.comment && (m = d.comment); else if (q(d)) { const y = W(d.key) ? d.key : null; y && (!f && y.spaceBefore && g.push(""), Be(e, g, y.commentBefore, f)) } f = !1; let _ = ze(d, u, () => m = null, () => f = !0); m && (_ += te(_, o, c(m))), f && m && (f = !1), g.push(s + _) } let h; if (g.length === 0) h = r.start + r.end; else {
    h = g[0]; for (let p = 1; p < g.length; ++p) {
      const d = g[p]; h += d ? `
${l}${d}` : `
`}
  } return n ? (h += `
`+ _e(c(n), l), a && a()) : f && i && i(), h
} function Ga({ items: n }, t, { flowChars: e, itemIndent: s }) {
  const { indent: r, indentStep: o, flowCollectionPadding: i, options: { commentString: a } } = t; s += o; const l = Object.assign({}, t, { indent: s, inFlow: !0, type: null }); let c = !1, u = 0; const f = []; for (let p = 0; p < n.length; ++p) {
    const d = n[p]; let m = null; if (W(d)) d.spaceBefore && f.push(""), Be(t, f, d.commentBefore, !1), d.comment && (m = d.comment); else if (q(d)) { const y = W(d.key) ? d.key : null; y && (y.spaceBefore && f.push(""), Be(t, f, y.commentBefore, !1), y.comment && (c = !0)); const k = W(d.value) ? d.value : null; k ? (k.comment && (m = k.comment), k.commentBefore && (c = !0)) : d.value == null && (y != null && y.comment) && (m = y.comment) } m && (c = !0); let _ = ze(d, l, () => m = null); p < n.length - 1 && (_ += ","), m && (_ += te(_, s, a(m))), !c && (f.length > u || _.includes(`
`)) && (c = !0), f.push(_), u = f.length
  } const { start: g, end: h } = e; if (f.length === 0) return g + h; if (!c) { const p = f.reduce((d, m) => d + m.length + 2, 2); c = t.options.lineWidth > 0 && p > t.options.lineWidth } if (c) {
    let p = g; for (const d of f) p += d ? `
${o}${r}${d}` : `
`; return `${p}
${r}${h}`
  } else return `${g}${i}${f.join(" ")}${i}${h}`
} function Be({ indent: n, options: { commentString: t } }, e, s, r) { if (s && r && (s = s.replace(/^\n+/, "")), s) { const o = _e(t(s), n); e.push(o.trimStart()) } } function Ut(n, t) { const e = F(t) ? t.value : t; for (const s of n) if (q(s) && (s.key === t || s.key === e || F(s.key) && s.key.value === e)) return s } class Qt extends hr { static get tagName() { return "tag:yaml.org,2002:map" } constructor(t) { super(Jt, t), this.items = [] } static from(t, e, s) { const { keepUndefined: r, replacer: o } = s, i = new this(t), a = (l, c) => { if (typeof o == "function") c = o.call(e, l, c); else if (Array.isArray(o) && !o.includes(l)) return; (c !== void 0 || r) && i.items.push(xn(l, c, s)) }; if (e instanceof Map) for (const [l, c] of e) a(l, c); else if (e && typeof e == "object") for (const l of Object.keys(e)) a(l, e[l]); return typeof t.sortMapEntries == "function" && i.items.sort(t.sortMapEntries), i } add(t, e) { var i; let s; q(t) ? s = t : !t || typeof t != "object" || !("key" in t) ? s = new lt(t, t == null ? void 0 : t.value) : s = new lt(t.key, t.value); const r = Ut(this.items, s.key), o = (i = this.schema) == null ? void 0 : i.sortMapEntries; if (r) { if (!e) throw new Error(`Key ${s.key} already set`); F(r.value) && dr(s.value) ? r.value.value = s.value : r.value = s.value } else if (o) { const a = this.items.findIndex(l => o(s, l) < 0); a === -1 ? this.items.push(s) : this.items.splice(a, 0, s) } else this.items.push(s) } delete(t) { const e = Ut(this.items, t); return e ? this.items.splice(this.items.indexOf(e), 1).length > 0 : !1 } get(t, e) { const s = Ut(this.items, t), r = s == null ? void 0 : s.value; return (!e && F(r) ? r.value : r) ?? void 0 } has(t) { return !!Ut(this.items, t) } set(t, e) { this.add(new lt(t, e), !0) } toJSON(t, e, s) { const r = s ? new s : e != null && e.mapAsMap ? new Map : {}; e != null && e.onCreate && e.onCreate(r); for (const o of this.items) mr(e, r, o); return r } toString(t, e, s) { if (!t) return JSON.stringify(this); for (const r of this.items) if (!q(r)) throw new Error(`Map items must all be pairs; found ${JSON.stringify(r)} instead`); return !t.allNullValues && this.hasAllNullValues(!1) && (t = Object.assign({}, t, { allNullValues: !0 })), yr(this, t, { blockItemPrefix: "", flowChars: { start: "{", end: "}" }, itemIndent: t.indent || "", onChompKeep: s, onComment: e }) } } class _r extends hr { static get tagName() { return "tag:yaml.org,2002:seq" } constructor(t) { super(ve, t), this.items = [] } add(t) { this.items.push(t) } delete(t) { const e = $e(t); return typeof e != "number" ? !1 : this.items.splice(e, 1).length > 0 } get(t, e) { const s = $e(t); if (typeof s != "number") return; const r = this.items[s]; return !e && F(r) ? r.value : r } has(t) { const e = $e(t); return typeof e == "number" && e < this.items.length } set(t, e) { const s = $e(t); if (typeof s != "number") throw new Error(`Expected a valid index, not ${t}.`); const r = this.items[s]; F(r) && dr(e) ? r.value = e : this.items[s] = e } toJSON(t, e) { const s = []; e != null && e.onCreate && e.onCreate(s); let r = 0; for (const o of this.items) s.push(rt(o, String(r++), e)); return s } toString(t, e, s) { return t ? yr(this, t, { blockItemPrefix: "- ", flowChars: { start: "[", end: "]" }, itemIndent: (t.indent || "") + "  ", onChompKeep: s, onComment: e }) : JSON.stringify(this) } static from(t, e, s) { const { replacer: r } = s, o = new this(t); if (e && Symbol.iterator in Object(e)) { let i = 0; for (let a of e) { if (typeof r == "function") { const l = e instanceof Set ? a : String(i++); a = r.call(e, l, a) } o.items.push(Fe(a, void 0, s)) } } return o } } function $e(n) { let t = F(n) ? n.value : n; return t && typeof t == "string" && (t = Number(t)), typeof t == "number" && Number.isInteger(t) && t >= 0 ? t : null } function Qa(n, t, e) { const { replacer: s } = e, r = new _r(n); r.tag = "tag:yaml.org,2002:pairs"; let o = 0; if (t && Symbol.iterator in Object(t)) for (let i of t) { typeof s == "function" && (i = s.call(t, String(o++), i)); let a, l; if (Array.isArray(i)) if (i.length === 2) a = i[0], l = i[1]; else throw new TypeError(`Expected [key, value] tuple: ${i}`); else if (i && i instanceof Object) { const c = Object.keys(i); if (c.length === 1) a = c[0], l = i[a]; else throw new TypeError(`Expected tuple with one key, not ${c.length} keys`) } else a = i; r.items.push(xn(a, l, e)) } return r } class Vn extends _r { constructor() { super(), this.add = Qt.prototype.add.bind(this), this.delete = Qt.prototype.delete.bind(this), this.get = Qt.prototype.get.bind(this), this.has = Qt.prototype.has.bind(this), this.set = Qt.prototype.set.bind(this), this.tag = Vn.tag } toJSON(t, e) { if (!e) return super.toJSON(t); const s = new Map; e != null && e.onCreate && e.onCreate(s); for (const r of this.items) { let o, i; if (q(r) ? (o = rt(r.key, "", e), i = rt(r.value, o, e)) : o = rt(r, "", e), s.has(o)) throw new Error("Ordered maps must not include duplicate keys"); s.set(o, i) } return s } static from(t, e, s) { const r = Qa(t, e, s), o = new this; return o.items = r.items, o } } Vn.tag = "tag:yaml.org,2002:omap"; class Fn extends Qt { constructor(t) { super(t), this.tag = Fn.tag } add(t) { let e; q(t) ? e = t : t && typeof t == "object" && "key" in t && "value" in t && t.value === null ? e = new lt(t.key, null) : e = new lt(t, null), Ut(this.items, e.key) || this.items.push(e) } get(t, e) { const s = Ut(this.items, t); return !e && q(s) ? F(s.key) ? s.key.value : s.key : s } set(t, e) { if (typeof e != "boolean") throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof e}`); const s = Ut(this.items, t); s && !e ? this.items.splice(this.items.indexOf(s), 1) : !s && e && this.items.push(new lt(t)) } toJSON(t, e) { return super.toJSON(t, e, Set) } toString(t, e, s) { if (!t) return JSON.stringify(this); if (this.hasAllNullValues(!0)) return super.toString(Object.assign({}, t, { allNullValues: !0 }), e, s); throw new Error("Set items must all have null values") } static from(t, e, s) { const { replacer: r } = s, o = new this(t); if (e && Symbol.iterator in Object(e)) for (let i of e) typeof r == "function" && (i = r.call(e, i, i)), o.items.push(xn(i, null, s)); return o } } Fn.tag = "tag:yaml.org,2002:set"; new Set("0123456789ABCDEFabcdef"); new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()"); new Set(",[]{}"); new Set(` ,[]{}
\r	`); function zn(n = 5) { const t = [], e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", s = e.length; for (let r = 0; r < n; r++)t.push(e.charAt(Math.floor(Math.random() * s))); return t.join("") } function Dc(n, t, e, s) { const r = sr(t + e - 1, n); for (let o = 0; o < t; o++) { const i = s(o), a = r.includes(o + e); for (const l of i) l.classList.toggle("slidev-code-highlighted", a), l.classList.toggle("slidev-code-dishonored", !a), l.classList.toggle("highlighted", a), l.classList.toggle("dishonored", !a) } } function vr() { return Math.random().toString(36).replace(/[^a-z]+/g, "").substr(2, 10) } function tt(n, t, e) { Object.defineProperty(n, t, { value: e, writable: !0, enumerable: !1 }) } const ut = E({}); let Ya = [], Za = []; tt(ut, "$syncUp", !0); tt(ut, "$syncDown", !0); tt(ut, "$paused", !1); tt(ut, "$onSet", n => Ya.push(n)); tt(ut, "$onPatch", n => Za.push(n)); vr(); tt(ut, "$patch", async () => !1); const Xa = { channels: [], enabled: !0, init(n, t, e, s = !1) { let r; if (!s) r = new BroadcastChannel(n), r.addEventListener("message", o => t(o.data)), this.channels.push(r); else if (s) { this.listener = function (i) { i && i.key === n && i.newValue && t(JSON.parse(i.newValue)) }, window.addEventListener("storage", this.listener); const o = window.localStorage.getItem(n); o && t(JSON.parse(o)) } return (o, i = !1) => { this.enabled && (!s && r && !i && r.postMessage(Ys(o)), s && !i && window.localStorage.setItem(n, JSON.stringify(o))) } }, disable() { this.enabled = !1, this.channels.forEach(n => n.close()), this.listener && window.removeEventListener("storage", this.listener) } }, tl = E([Xa]), el = new Map, Is = D({}); function kr(n, t, e = !1) { const s = []; let r = !1, o = !1, i, a; const l = E(t); function c(h) { s.push(h) } function u(h, p) { l[h] !== p && (clearTimeout(i), r = !0, l[h] = p, i = setTimeout(() => r = !1, 0)) } function f(h) { r || (clearTimeout(a), o = !0, Object.entries(h).forEach(([p, d]) => { l[p] = d }), a = setTimeout(() => o = !1, 0)) } function g(h) { el.set(h, { onUpdate: f, persist: e, state: l }), Is.value[h] = tl.map(d => d.init(h, f, l, e)).filter(d => !!d); function p() { Is.value[h].forEach(d => d == null ? void 0 : d(Ys(l), o)), r || s.forEach(d => d(l)) } ot(l, p, { deep: !0 }) } return { init: g, onPatch: c, onUpdate: f, patch: u, state: l } } const { init: nl, onPatch: Ic, patch: Rc, state: Nc } = kr(ut, ut, !1), Kt = E({ page: 0, clicks: 0 }); let sl = [], rl = []; tt(Kt, "$syncUp", !0); tt(Kt, "$syncDown", !0); tt(Kt, "$paused", !1); tt(Kt, "$onSet", n => sl.push(n)); tt(Kt, "$onPatch", n => rl.push(n)); vr(); tt(Kt, "$patch", async () => !1); const { init: ol, onPatch: il, patch: Le, state: jc } = kr(Kt, { page: 1, clicks: 0, clicksTotal: 0 }); function al() { const n = Us().appContext.app, t = E({ nav: re(), configs: J, themeConfigs: S(() => J.themeConfig) }); n.provide(Dn, D("none")), n.provide(la, t), n.provide(Cn, S(() => t.nav.currentSlideNo)), n.provide(Ke, Pn(Wo())); for (const g of yo) g(); const { clicksContext: e, currentSlideNo: s, hasPrimarySlide: r, isNotesViewer: o, isPresenter: i, isPrintMode: a } = re(); zo({ title: en, htmlAttrs: J.htmlAttrs }), La(), ol(`${en} - shared`), nl(`${en} - drawings`); const l = `${location.origin}_${zn()}`, c = S(() => i.value ? "presenter" : "viewer"); function u() { (i.value ? Me.value.presenterSend : Me.value.viewerSend) && (o.value || a.value || !i.value && !fa.includes(location.host.split(":")[0]) || (Le("page", +s.value), Le("clicks", e.value.current), Le("clicksTotal", e.value.total), Le("lastUpdate", { id: l, type: c.value, time: new Date().getTime() }))) } const f = Je(); f.afterEach(u), ot(e, u), il(g => { var p; (i.value ? Me.value.presenterReceive : Me.value.viewerReceive) && (!r.value || a.value || ((p = g.lastUpdate) == null ? void 0 : p.type) !== c.value && (+g.page == +s.value && +e.value.current == +g.clicks || (In.value = !1, f.replace({ path: Zt(g.page, i.value), query: { ...f.currentRoute.value.query, clicks: g.clicks || 0 } })))) }) } const ll = Ks({ __name: "App", setup(n) { return al(), ne(() => { for (const [t, e] of Object.entries(go.value)) document.body.style.setProperty(t, e.toString()) }), (t, e) => { const s = to("RouterView"); return je(), Xr(s) } } }), cl = []; async function wr(n, t = {}) { const e = t.document || n.resolvedOptions.document; if (!e || !n.dirty) return; const s = { shouldRender: !0, tags: [] }; if (await n.hooks.callHook("dom:beforeRender", s), !!s.shouldRender) return n._domUpdatePromise || (n._domUpdatePromise = new Promise(async r => { var h; const o = new Map, i = new Promise(p => { n.resolveTags().then(d => { p(d.map(m => { const _ = o.get(m._d) || 0, y = { tag: m, id: (_ ? `${m._d}:${_}` : m._d) || Qn(m), shouldRender: !0 }; return m._d && Xs(m._d) && o.set(m._d, _ + 1), y })) }) }); let a = n._dom; if (!a) { a = { title: e.title, elMap: new Map().set("htmlAttrs", e.documentElement).set("bodyAttrs", e.body) }; for (const p of ["body", "head"]) { const d = (h = e[p]) == null ? void 0 : h.children; for (const m of d) { const _ = m.tagName.toLowerCase(); if (!Gn.has(_)) continue; const y = tr({ tag: _, props: {} }, { innerHTML: m.innerHTML, ...m.getAttributeNames().reduce((k, w) => (k[w] = m.getAttribute(w), k), {}) || {} }); if (y.key = m.getAttribute("data-hid") || void 0, y._d = yn(y) || Qn(y), a.elMap.has(y._d)) { let k = 1, w = y._d; for (; a.elMap.has(w);)w = `${y._d}:${k++}`; a.elMap.set(w, m) } else a.elMap.set(y._d, m) } } } a.pendingSideEffects = { ...a.sideEffects }, a.sideEffects = {}; function l(p, d, m) { const _ = `${p}:${d}`; a.sideEffects[_] = m, delete a.pendingSideEffects[_] } function c({ id: p, $el: d, tag: m }) { const _ = m.tag.endsWith("Attrs"); a.elMap.set(p, d), _ || (m.textContent && m.textContent !== d.textContent && (d.textContent = m.textContent), m.innerHTML && m.innerHTML !== d.innerHTML && (d.innerHTML = m.innerHTML), l(p, "el", () => { d == null || d.remove(), a.elMap.delete(p) })); for (const y in m.props) { if (!Object.prototype.hasOwnProperty.call(m.props, y)) continue; const k = m.props[y]; if (y.startsWith("on") && typeof k == "function") { const b = d == null ? void 0 : d.dataset; if (b && b[`${y}fired`]) { const O = y.slice(0, -5); k.call(d, new Event(O.substring(2))) } d.getAttribute(`data-${y}`) !== "" && ((m.tag === "bodyAttrs" ? e.defaultView : d).addEventListener(y.substring(2), k.bind(d)), d.setAttribute(`data-${y}`, "")); continue } const w = `attr:${y}`; if (y === "class") { if (!k) continue; for (const b of k) _ && l(p, `${w}:${b}`, () => d.classList.remove(b)), !d.classList.contains(b) && d.classList.add(b) } else if (y === "style") { if (!k) continue; for (const [b, O] of k) l(p, `${w}:${b}`, () => { d.style.removeProperty(b) }), d.style.setProperty(b, O) } else k !== !1 && k !== null && (d.getAttribute(y) !== k && d.setAttribute(y, k === !0 ? "" : String(k)), _ && l(p, w, () => d.removeAttribute(y))) } } const u = [], f = { bodyClose: void 0, bodyOpen: void 0, head: void 0 }, g = await i; for (const p of g) { const { tag: d, shouldRender: m, id: _ } = p; if (m) { if (d.tag === "title") { e.title = d.textContent, l("title", "", () => e.title = a.title); continue } p.$el = p.$el || a.elMap.get(_), p.$el ? c(p) : Gn.has(d.tag) && u.push(p) } } for (const p of u) { const d = p.tag.tagPosition || "head"; p.$el = e.createElement(p.tag.tag), c(p), f[d] = f[d] || e.createDocumentFragment(), f[d].appendChild(p.$el) } for (const p of g) await n.hooks.callHook("dom:renderTag", p, e, l); f.head && e.head.appendChild(f.head), f.bodyOpen && e.body.insertBefore(f.bodyOpen, e.body.firstChild), f.bodyClose && e.body.appendChild(f.bodyClose); for (const p in a.pendingSideEffects) a.pendingSideEffects[p](); n._dom = a, await n.hooks.callHook("dom:rendered", { renders: g }), r() }).finally(() => { n._domUpdatePromise = void 0, n.dirty = !1 })), n._domUpdatePromise } function ul(n = {}) { var s, r, o; const t = ((s = n.domOptions) == null ? void 0 : s.render) || wr; n.document = n.document || (typeof window < "u" ? document : void 0); const e = ((o = (r = n.document) == null ? void 0 : r.head.querySelector('script[id="unhead:payload"]')) == null ? void 0 : o.innerHTML) || !1; return Ho({ ...n, plugins: [...n.plugins || [], { key: "client", hooks: { "entries:updated": t } }], init: [e ? JSON.parse(e) : !1, ...n.init || []] }) } function fl(n, t) { let e = 0; return () => { const s = ++e; t(() => { e === s && n() }) } } function dl(n = {}) { const t = ul({ domOptions: { render: fl(() => wr(t), Gs) }, ...n }); return t.install = Vo(t), t } function Hc(n, t = "") { var r, o; const e = ["slidev-page", t], s = (o = (r = n == null ? void 0 : n.meta) == null ? void 0 : r.slide) == null ? void 0 : o.no; return s != null && e.push(`slidev-page-${s}`), e.filter(Boolean).join(" ") } async function xc() { const { saveAs: n } = await $(async () => { const { saveAs: t } = await import("./modules/file-saver-BzOOqXCn.js").then(e => e.F); return { saveAs: t } }, []); n(typeof J.download == "string" ? J.download : J.exportFilename ? `${J.exportFilename}.pdf` : "/service-domain-reviewslidev-exported.pdf", `${J.title}.pdf`) } function se(n, t, e) { var s; return ((s = n.instance) == null ? void 0 : s.$).provides[t] ?? e } function hl() { return { install(n) { n.directive("click", { name: "v-click", mounted(t, e) { const s = Re(t, e, e.value); s != null && (t.classList.toggle(Pe, !0), t.dataset.slidevClicksStart = String(s.start), Number.isFinite(s.end) && (t.dataset.slidevClicksEnd = String(s.end)), t.watchStopHandle = ne(() => { const r = s.isActive.value, o = s.isCurrent.value, i = r && !o; s.flagHide ? (t.classList.toggle(s.flagFade ? ue : ce, r), t.classList.toggle(sn, r)) : t.classList.toggle(s.flagFade ? ue : ce, !r), t.classList.toggle(rn, o), t.classList.toggle(on, i) })) }, unmounted: cn }), n.directive("after", { name: "v-after", mounted(t, e) { const s = Re(t, e, "+0"); s != null && (t.classList.toggle(Pe, !0), t.watchStopHandle = ne(() => { const r = s.isActive.value, o = s.isCurrent.value, i = r && !o; s.flagHide ? (t.classList.toggle(s.flagFade ? ue : ce, r), t.classList.toggle(sn, r)) : t.classList.toggle(s.flagFade ? ue : ce, !r), t.classList.toggle(rn, o), t.classList.toggle(on, i) })) }, unmounted: cn }), n.directive("click-hide", { name: "v-click-hide", mounted(t, e) { const s = Re(t, e, e.value, !0); s != null && (t.classList.toggle(Pe, !0), t.watchStopHandle = ne(() => { const r = s.isActive.value, o = s.isCurrent.value, i = r && !o; t.classList.toggle(s.flagFade ? ue : ce, r), t.classList.toggle(sn, r), t.classList.toggle(rn, o), t.classList.toggle(on, i) })) }, unmounted: cn }) } } } const br = new Map; function Re(n, t, e, s = !1) { var f; const r = (f = se(t, Ke)) == null ? void 0 : f.value; if (!n || !r) return null; const o = s || t.modifiers.hide !== !1 && t.modifiers.hide != null, i = t.modifiers.fade !== !1 && t.modifiers.fade != null, a = r.calculate(e); if (!a) return null; r.register(n, a); const l = S(() => o ? !a.isActive.value : a.isActive.value), c = S(() => l.value ? "shown" : Number.isFinite(a.end) ? r.current < a.start ? "before" : "after" : o ? "after" : "before"), u = { ...a, isShown: l, visibilityState: c, flagFade: i, flagHide: o }; return br.set(n, u), u } function cn(n, t) { var s, r; n.classList.toggle(Pe, !1); const e = (s = se(t, Ke)) == null ? void 0 : s.value; e == null || e.unregister(n), (r = n.watchStopHandle) == null || r.call(n) } function pl(n = Ws(rr, D())) { const t = eo(n), e = ot([va, ka, wa, ba, _a, xe.width, xe.height], () => { setTimeout(t.update, 300) }, { flush: "post", immediate: !0 }); return { ...t, stop: e } } function gl(n) { return () => { } } function ml(n, t, e, s = !1) { var we; function r(x) { return n ? se(n, x) : ro(x) } const o = r(Dn), i = r(ca) ?? {}, a = r(Cn), l = S(() => gl(a.value)), c = r(aa) ?? D(1), u = r(ua) ?? D(1), { left: f, top: g, stop: h } = pl(r(rr) ?? D()), { isPrintMode: p } = re(), d = ["slide", "presenter"].includes(o.value) && !p.value; let m = n ? "directive" : "prop", _ = zn(), y; if (Array.isArray(t) ? y = t : typeof t == "string" && t.includes(",") ? y = t.split(",").map(Number) : t != null && (m = "frontmatter", _ = `${t}`, t = (we = i == null ? void 0 : i.dragPos) == null ? void 0 : we[_], y = t == null ? void 0 : t.split(",").map(Number)), m !== "frontmatter" && !e) throw new Error("[Slidev] Can not identify the source position of the v-drag element, please provide an explicit `id` prop."); const k = [h], w = !s && t != null && !Number.isFinite(y == null ? void 0 : y[3]); y ?? (y = [Number.NaN, Number.NaN, 0]); const b = D(y[2]), O = D(y[0] + y[2] / 2), L = D(s ? 0 : y[4] ?? 0), I = S(() => L.value * Math.PI / 180), V = S(() => Math.sin(I.value)), et = S(() => Math.cos(I.value)), Z = D(), T = D({ left: 0, top: 0, width: 0, height: 0 }), R = D(0); function z() { if (!Z.value) return; const x = Z.value.getBoundingClientRect(); T.value = { left: x.left / u.value, top: x.top / u.value, width: x.width / u.value, height: x.height / u.value }, R.value = (T.value.width + T.value.height) / c.value / (Math.abs(V.value) + Math.abs(et.value)) - b.value } k.push(ot(b, z, { flush: "post" })); const N = D(y[3] ?? 0), j = w ? S({ get: () => (w ? R.value : N.value) || 0, set: x => !w && (N.value = x) }) : N, at = w ? D(y[1]) : D(y[1] + y[3] / 2), ct = w ? S({ get: () => at.value + j.value / 2, set: x => at.value = x - j.value / 2 }) : at, ie = S(() => Number.isFinite(O.value) ? { position: "absolute", zIndex: 100, left: `${O.value - b.value / 2}px`, top: `${ct.value - j.value / 2}px`, width: `${b.value}px`, height: w ? void 0 : `${j.value}px`, transformOrigin: "center center", transform: `rotate(${L.value}deg)` } : { position: "absolute", zIndex: 100 }); k.push(ot([O, ct, b, j, L], ([x, dt, ae, Wn, Un]) => { let Gt = [x - ae / 2, dt - Wn / 2, ae].map(Math.round).join(); w ? Gt += m === "directive" ? ",NaN" : ",_" : Gt += `,${Math.round(Wn)}`, Math.round(Un) !== 0 && (Gt += `,${Math.round(Un)}`), m === "directive" && (Gt = `[${Gt}]`), l.value(_, Gt, m, e) })); const B = { dragId: _, dataSource: m, markdownSource: e, isArrow: s, zoom: u, autoHeight: w, x0: O, y0: ct, width: b, height: j, rotate: L, container: Z, containerStyle: ie, watchStopHandles: k, dragging: S(() => be.value === B), mounted() { d && (z(), t || setTimeout(() => { z(), O.value = (T.value.left + T.value.width / 2 - f.value) / c.value, ct.value = (T.value.top - g.value) / c.value, b.value = T.value.width / c.value, j.value = T.value.height / c.value }, 100)) }, unmounted() { d && B.stopDragging() }, startDragging() { d && (z(), be.value = B) }, stopDragging() { d && be.value === B && (be.value = null) } }; return k.push(no(Z, x => { const dt = document.querySelector("#drag-control-container"); dt && x.target && dt.contains(x.target) || B.stopDragging() }), ot(so(), x => { x || B.stopDragging() })), B } function yl() { return { install(n) { n.directive("drag", { name: "v-drag", created(t, e, s) { var o; const r = ml(e, e.value, (o = s.props) == null ? void 0 : o.markdownSource); s.props && (s.props = { ...s.props }, delete s.props.markdownSource), r.container.value = t, t.draggingState = r, t.dataset.dragId = r.dragId, r.watchStopHandles.push(ot(r.containerStyle, i => { for (const [a, l] of Object.entries(i)) l && (t.style[a] = l) }, { immediate: !0 })), t.addEventListener("dblclick", r.startDragging) }, mounted(t) { t.draggingState.mounted() }, unmounted(t) { const e = t.draggingState; e.unmounted(), t.removeEventListener("dblclick", e.startDragging), e.watchStopHandles.forEach(s => s()) } }) } } } function Sr() { return Math.floor(Math.random() * 2 ** 31) } class _l { constructor(t) { this.seed = t } next() { return this.seed ? (2 ** 31 - 1 & (this.seed = Math.imul(48271, this.seed))) / 2 ** 31 : Math.random() } } function Sn(n, t, e) { if (n && n.length) { const [s, r] = t, o = Math.PI / 180 * e, i = Math.cos(o), a = Math.sin(o); for (const l of n) { const [c, u] = l; l[0] = (c - s) * i - (u - r) * a + s, l[1] = (c - s) * a + (u - r) * i + r } } } function vl(n, t, e) { const s = []; n.forEach(r => s.push(...r)), Sn(s, t, e) } function kl(n, t) { return n[0] === t[0] && n[1] === t[1] } function wl(n, t, e, s = 1) { const r = e, o = Math.max(t, .1), i = n[0] && n[0][0] && typeof n[0][0] == "number" ? [n] : n, a = [0, 0]; if (r) for (const c of i) Sn(c, a, r); const l = bl(i, o, s); if (r) { for (const c of i) Sn(c, a, -r); vl(l, a, -r) } return l } function bl(n, t, e) { const s = []; for (const c of n) { const u = [...c]; kl(u[0], u[u.length - 1]) || u.push([u[0][0], u[0][1]]), u.length > 2 && s.push(u) } const r = []; t = Math.max(t, .1); const o = []; for (const c of s) for (let u = 0; u < c.length - 1; u++) { const f = c[u], g = c[u + 1]; if (f[1] !== g[1]) { const h = Math.min(f[1], g[1]); o.push({ ymin: h, ymax: Math.max(f[1], g[1]), x: h === f[1] ? f[0] : g[0], islope: (g[0] - f[0]) / (g[1] - f[1]) }) } } if (o.sort((c, u) => c.ymin < u.ymin ? -1 : c.ymin > u.ymin ? 1 : c.x < u.x ? -1 : c.x > u.x ? 1 : c.ymax === u.ymax ? 0 : (c.ymax - u.ymax) / Math.abs(c.ymax - u.ymax)), !o.length) return r; let i = [], a = o[0].ymin, l = 0; for (; i.length || o.length;) { if (o.length) { let c = -1; for (let f = 0; f < o.length && !(o[f].ymin > a); f++)c = f; o.splice(0, c + 1).forEach(f => { i.push({ s: a, edge: f }) }) } if (i = i.filter(c => !(c.edge.ymax <= a)), i.sort((c, u) => c.edge.x === u.edge.x ? 0 : (c.edge.x - u.edge.x) / Math.abs(c.edge.x - u.edge.x)), (e !== 1 || l % t === 0) && i.length > 1) for (let c = 0; c < i.length; c = c + 2) { const u = c + 1; if (u >= i.length) break; const f = i[c].edge, g = i[u].edge; r.push([[Math.round(f.x), a], [Math.round(g.x), a]]) } a += e, i.forEach(c => { c.edge.x = c.edge.x + e * c.edge.islope }), l++ } return r } function ke(n, t) { var e; const s = t.hachureAngle + 90; let r = t.hachureGap; r < 0 && (r = t.strokeWidth * 4), r = Math.round(Math.max(r, .1)); let o = 1; return t.roughness >= 1 && (((e = t.randomizer) === null || e === void 0 ? void 0 : e.next()) || Math.random()) > .7 && (o = r), wl(n, r, s, o || 1) } class Bn { constructor(t) { this.helper = t } fillPolygons(t, e) { return this._fillPolygons(t, e) } _fillPolygons(t, e) { const s = ke(t, e); return { type: "fillSketch", ops: this.renderLines(s, e) } } renderLines(t, e) { const s = []; for (const r of t) s.push(...this.helper.doubleLineOps(r[0][0], r[0][1], r[1][0], r[1][1], e)); return s } } function tn(n) { const t = n[0], e = n[1]; return Math.sqrt(Math.pow(t[0] - e[0], 2) + Math.pow(t[1] - e[1], 2)) } class Sl extends Bn { fillPolygons(t, e) { let s = e.hachureGap; s < 0 && (s = e.strokeWidth * 4), s = Math.max(s, .1); const r = Object.assign({}, e, { hachureGap: s }), o = ke(t, r), i = Math.PI / 180 * e.hachureAngle, a = [], l = s * .5 * Math.cos(i), c = s * .5 * Math.sin(i); for (const [f, g] of o) tn([f, g]) && a.push([[f[0] - l, f[1] + c], [...g]], [[f[0] + l, f[1] - c], [...g]]); return { type: "fillSketch", ops: this.renderLines(a, e) } } } class Ml extends Bn { fillPolygons(t, e) { const s = this._fillPolygons(t, e), r = Object.assign({}, e, { hachureAngle: e.hachureAngle + 90 }), o = this._fillPolygons(t, r); return s.ops = s.ops.concat(o.ops), s } } class Ol { constructor(t) { this.helper = t } fillPolygons(t, e) { e = Object.assign({}, e, { hachureAngle: 0 }); const s = ke(t, e); return this.dotsOnLines(s, e) } dotsOnLines(t, e) { const s = []; let r = e.hachureGap; r < 0 && (r = e.strokeWidth * 4), r = Math.max(r, .1); let o = e.fillWeight; o < 0 && (o = e.strokeWidth / 2); const i = r / 4; for (const a of t) { const l = tn(a), c = l / r, u = Math.ceil(c) - 1, f = l - u * r, g = (a[0][0] + a[1][0]) / 2 - r / 4, h = Math.min(a[0][1], a[1][1]); for (let p = 0; p < u; p++) { const d = h + f + p * r, m = g - i + Math.random() * 2 * i, _ = d - i + Math.random() * 2 * i, y = this.helper.ellipse(m, _, o, o, e); s.push(...y.ops) } } return { type: "fillSketch", ops: s } } } class $l { constructor(t) { this.helper = t } fillPolygons(t, e) { const s = ke(t, e); return { type: "fillSketch", ops: this.dashedLine(s, e) } } dashedLine(t, e) { const s = e.dashOffset < 0 ? e.hachureGap < 0 ? e.strokeWidth * 4 : e.hachureGap : e.dashOffset, r = e.dashGap < 0 ? e.hachureGap < 0 ? e.strokeWidth * 4 : e.hachureGap : e.dashGap, o = []; return t.forEach(i => { const a = tn(i), l = Math.floor(a / (s + r)), c = (a + r - l * (s + r)) / 2; let u = i[0], f = i[1]; u[0] > f[0] && (u = i[1], f = i[0]); const g = Math.atan((f[1] - u[1]) / (f[0] - u[0])); for (let h = 0; h < l; h++) { const p = h * (s + r), d = p + s, m = [u[0] + p * Math.cos(g) + c * Math.cos(g), u[1] + p * Math.sin(g) + c * Math.sin(g)], _ = [u[0] + d * Math.cos(g) + c * Math.cos(g), u[1] + d * Math.sin(g) + c * Math.sin(g)]; o.push(...this.helper.doubleLineOps(m[0], m[1], _[0], _[1], e)) } }), o } } class Ll { constructor(t) { this.helper = t } fillPolygons(t, e) { const s = e.hachureGap < 0 ? e.strokeWidth * 4 : e.hachureGap, r = e.zigzagOffset < 0 ? s : e.zigzagOffset; e = Object.assign({}, e, { hachureGap: s + r }); const o = ke(t, e); return { type: "fillSketch", ops: this.zigzagLines(o, r, e) } } zigzagLines(t, e, s) { const r = []; return t.forEach(o => { const i = tn(o), a = Math.round(i / (2 * e)); let l = o[0], c = o[1]; l[0] > c[0] && (l = o[1], c = o[0]); const u = Math.atan((c[1] - l[1]) / (c[0] - l[0])); for (let f = 0; f < a; f++) { const g = f * 2 * e, h = (f + 1) * 2 * e, p = Math.sqrt(2 * Math.pow(e, 2)), d = [l[0] + g * Math.cos(u), l[1] + g * Math.sin(u)], m = [l[0] + h * Math.cos(u), l[1] + h * Math.sin(u)], _ = [d[0] + p * Math.cos(u + Math.PI / 4), d[1] + p * Math.sin(u + Math.PI / 4)]; r.push(...this.helper.doubleLineOps(d[0], d[1], _[0], _[1], s), ...this.helper.doubleLineOps(_[0], _[1], m[0], m[1], s)) } }), r } } const K = {}; function El(n, t) { let e = n.fillStyle || "hachure"; if (!K[e]) switch (e) { case "zigzag": K[e] || (K[e] = new Sl(t)); break; case "cross-hatch": K[e] || (K[e] = new Ml(t)); break; case "dots": K[e] || (K[e] = new Ol(t)); break; case "dashed": K[e] || (K[e] = new $l(t)); break; case "zigzag-line": K[e] || (K[e] = new Ll(t)); break; case "hachure": default: e = "hachure", K[e] || (K[e] = new Bn(t)); break }return K[e] } const Tl = 0, Mn = 1, Mr = 2, Ee = { A: 7, a: 7, C: 6, c: 6, H: 1, h: 1, L: 2, l: 2, M: 2, m: 2, Q: 4, q: 4, S: 4, s: 4, T: 2, t: 2, V: 1, v: 1, Z: 0, z: 0 }; function Pl(n) { const t = new Array; for (; n !== "";)if (n.match(/^([ \t\r\n,]+)/)) n = n.substr(RegExp.$1.length); else if (n.match(/^([aAcChHlLmMqQsStTvVzZ])/)) t[t.length] = { type: Tl, text: RegExp.$1 }, n = n.substr(RegExp.$1.length); else if (n.match(/^(([-+]?[0-9]+(\.[0-9]*)?|[-+]?\.[0-9]+)([eE][-+]?[0-9]+)?)/)) t[t.length] = { type: Mn, text: `${parseFloat(RegExp.$1)}` }, n = n.substr(RegExp.$1.length); else return []; return t[t.length] = { type: Mr, text: "" }, t } function un(n, t) { return n.type === t } function qn(n) { const t = [], e = Pl(n); let s = "BOD", r = 0, o = e[r]; for (; !un(o, Mr);) { let i = 0; const a = []; if (s === "BOD") if (o.text === "M" || o.text === "m") r++, i = Ee[o.text], s = o.text; else return qn("M0,0" + n); else un(o, Mn) ? i = Ee[s] : (r++, i = Ee[o.text], s = o.text); if (r + i < e.length) { for (let l = r; l < r + i; l++) { const c = e[l]; if (un(c, Mn)) a[a.length] = +c.text; else throw new Error("Param not a number: " + s + "," + c.text) } if (typeof Ee[s] == "number") { const l = { key: s, data: a }; t.push(l), r += i, o = e[r], s === "M" && (s = "L"), s === "m" && (s = "l") } else throw new Error("Bad segment: " + s) } else throw new Error("Path data ended short") } return t } function Or(n) { let t = 0, e = 0, s = 0, r = 0; const o = []; for (const { key: i, data: a } of n) switch (i) { case "M": o.push({ key: "M", data: [...a] }), [t, e] = a, [s, r] = a; break; case "m": t += a[0], e += a[1], o.push({ key: "M", data: [t, e] }), s = t, r = e; break; case "L": o.push({ key: "L", data: [...a] }), [t, e] = a; break; case "l": t += a[0], e += a[1], o.push({ key: "L", data: [t, e] }); break; case "C": o.push({ key: "C", data: [...a] }), t = a[4], e = a[5]; break; case "c": { const l = a.map((c, u) => u % 2 ? c + e : c + t); o.push({ key: "C", data: l }), t = l[4], e = l[5]; break } case "Q": o.push({ key: "Q", data: [...a] }), t = a[2], e = a[3]; break; case "q": { const l = a.map((c, u) => u % 2 ? c + e : c + t); o.push({ key: "Q", data: l }), t = l[2], e = l[3]; break } case "A": o.push({ key: "A", data: [...a] }), t = a[5], e = a[6]; break; case "a": t += a[5], e += a[6], o.push({ key: "A", data: [a[0], a[1], a[2], a[3], a[4], t, e] }); break; case "H": o.push({ key: "H", data: [...a] }), t = a[0]; break; case "h": t += a[0], o.push({ key: "H", data: [t] }); break; case "V": o.push({ key: "V", data: [...a] }), e = a[0]; break; case "v": e += a[0], o.push({ key: "V", data: [e] }); break; case "S": o.push({ key: "S", data: [...a] }), t = a[2], e = a[3]; break; case "s": { const l = a.map((c, u) => u % 2 ? c + e : c + t); o.push({ key: "S", data: l }), t = l[2], e = l[3]; break } case "T": o.push({ key: "T", data: [...a] }), t = a[0], e = a[1]; break; case "t": t += a[0], e += a[1], o.push({ key: "T", data: [t, e] }); break; case "Z": case "z": o.push({ key: "Z", data: [] }), t = s, e = r; break }return o } function $r(n) { const t = []; let e = "", s = 0, r = 0, o = 0, i = 0, a = 0, l = 0; for (const { key: c, data: u } of n) { switch (c) { case "M": t.push({ key: "M", data: [...u] }), [s, r] = u, [o, i] = u; break; case "C": t.push({ key: "C", data: [...u] }), s = u[4], r = u[5], a = u[2], l = u[3]; break; case "L": t.push({ key: "L", data: [...u] }), [s, r] = u; break; case "H": s = u[0], t.push({ key: "L", data: [s, r] }); break; case "V": r = u[0], t.push({ key: "L", data: [s, r] }); break; case "S": { let f = 0, g = 0; e === "C" || e === "S" ? (f = s + (s - a), g = r + (r - l)) : (f = s, g = r), t.push({ key: "C", data: [f, g, ...u] }), a = u[0], l = u[1], s = u[2], r = u[3]; break } case "T": { const [f, g] = u; let h = 0, p = 0; e === "Q" || e === "T" ? (h = s + (s - a), p = r + (r - l)) : (h = s, p = r); const d = s + 2 * (h - s) / 3, m = r + 2 * (p - r) / 3, _ = f + 2 * (h - f) / 3, y = g + 2 * (p - g) / 3; t.push({ key: "C", data: [d, m, _, y, f, g] }), a = h, l = p, s = f, r = g; break } case "Q": { const [f, g, h, p] = u, d = s + 2 * (f - s) / 3, m = r + 2 * (g - r) / 3, _ = h + 2 * (f - h) / 3, y = p + 2 * (g - p) / 3; t.push({ key: "C", data: [d, m, _, y, h, p] }), a = f, l = g, s = h, r = p; break } case "A": { const f = Math.abs(u[0]), g = Math.abs(u[1]), h = u[2], p = u[3], d = u[4], m = u[5], _ = u[6]; f === 0 || g === 0 ? (t.push({ key: "C", data: [s, r, m, _, m, _] }), s = m, r = _) : (s !== m || r !== _) && (Lr(s, r, m, _, f, g, h, p, d).forEach(function (k) { t.push({ key: "C", data: k }) }), s = m, r = _); break } case "Z": t.push({ key: "Z", data: [] }), s = o, r = i; break }e = c } return t } function Al(n) { return Math.PI * n / 180 } function fe(n, t, e) { const s = n * Math.cos(e) - t * Math.sin(e), r = n * Math.sin(e) + t * Math.cos(e); return [s, r] } function Lr(n, t, e, s, r, o, i, a, l, c) { const u = Al(i); let f = [], g = 0, h = 0, p = 0, d = 0; if (c) [g, h, p, d] = c; else { [n, t] = fe(n, t, -u), [e, s] = fe(e, s, -u); const T = (n - e) / 2, R = (t - s) / 2; let z = T * T / (r * r) + R * R / (o * o); z > 1 && (z = Math.sqrt(z), r = z * r, o = z * o); const N = a === l ? -1 : 1, j = r * r, at = o * o, ct = j * at - j * R * R - at * T * T, ie = j * R * R + at * T * T, B = N * Math.sqrt(Math.abs(ct / ie)); p = B * r * R / o + (n + e) / 2, d = B * -o * T / r + (t + s) / 2, g = Math.asin(parseFloat(((t - d) / o).toFixed(9))), h = Math.asin(parseFloat(((s - d) / o).toFixed(9))), n < p && (g = Math.PI - g), e < p && (h = Math.PI - h), g < 0 && (g = Math.PI * 2 + g), h < 0 && (h = Math.PI * 2 + h), l && g > h && (g = g - Math.PI * 2), !l && h > g && (h = h - Math.PI * 2) } let m = h - g; if (Math.abs(m) > Math.PI * 120 / 180) { const T = h, R = e, z = s; l && h > g ? h = g + Math.PI * 120 / 180 * 1 : h = g + Math.PI * 120 / 180 * -1, e = p + r * Math.cos(h), s = d + o * Math.sin(h), f = Lr(e, s, R, z, r, o, i, 0, l, [h, T, p, d]) } m = h - g; const _ = Math.cos(g), y = Math.sin(g), k = Math.cos(h), w = Math.sin(h), b = Math.tan(m / 4), O = 4 / 3 * r * b, L = 4 / 3 * o * b, I = [n, t], V = [n + O * y, t - L * _], et = [e + O * w, s - L * k], Z = [e, s]; if (V[0] = 2 * I[0] - V[0], V[1] = 2 * I[1] - V[1], c) return [V, et, Z].concat(f); { f = [V, et, Z].concat(f); const T = []; for (let R = 0; R < f.length; R += 3) { const z = fe(f[R][0], f[R][1], u), N = fe(f[R + 1][0], f[R + 1][1], u), j = fe(f[R + 2][0], f[R + 2][1], u); T.push([z[0], z[1], N[0], N[1], j[0], j[1]]) } return T } } const Cl = { randOffset: Rl, randOffsetWithRange: Nl, ellipse: On, doubleLineOps: jl }; function X(n, t, e, s, r) { return { type: "path", ops: ft(n, t, e, s, r) } } function me(n, t, e) { const s = (n || []).length; if (s > 2) { const r = []; for (let o = 0; o < s - 1; o++)r.push(...ft(n[o][0], n[o][1], n[o + 1][0], n[o + 1][1], e)); return t && r.push(...ft(n[s - 1][0], n[s - 1][1], n[0][0], n[0][1], e)), { type: "path", ops: r } } else if (s === 2) return X(n[0][0], n[0][1], n[1][0], n[1][1], e); return { type: "path", ops: [] } } function Dl(n, t) { return me(n, !0, t) } function Er(n, t, e, s, r) { const o = [[n, t], [n + e, t], [n + e, t + s], [n, t + s]]; return Dl(o, r) } function Rs(n, t) { if (n.length) { const s = typeof n[0][0] == "number" ? [n] : n, r = Te(s[0], 1 * (1 + t.roughness * .2), t), o = t.disableMultiStroke ? [] : Te(s[0], 1.5 * (1 + t.roughness * .22), Hs(t)); for (let i = 1; i < s.length; i++) { const a = s[i]; if (a.length) { const l = Te(a, 1 * (1 + t.roughness * .2), t), c = t.disableMultiStroke ? [] : Te(a, 1.5 * (1 + t.roughness * .22), Hs(t)); for (const u of l) u.op !== "move" && r.push(u); for (const u of c) u.op !== "move" && o.push(u) } } return { type: "path", ops: r.concat(o) } } return { type: "path", ops: [] } } function On(n, t, e, s, r) { const o = Tr(e, s, r); return $n(n, t, r, o).opset } function Tr(n, t, e) { const s = Math.sqrt(Math.PI * 2 * Math.sqrt((Math.pow(n / 2, 2) + Math.pow(t / 2, 2)) / 2)), r = Math.ceil(Math.max(e.curveStepCount, e.curveStepCount / Math.sqrt(200) * s)), o = Math.PI * 2 / r; let i = Math.abs(n / 2), a = Math.abs(t / 2); const l = 1 - e.curveFitting; return i += M(i * l, e), a += M(a * l, e), { increment: o, rx: i, ry: a } } function $n(n, t, e, s) { const [r, o] = xs(s.increment, n, t, s.rx, s.ry, 1, s.increment * qe(.1, qe(.4, 1, e), e), e); let i = We(r, null, e); if (!e.disableMultiStroke && e.roughness !== 0) { const [a] = xs(s.increment, n, t, s.rx, s.ry, 1.5, 0, e), l = We(a, null, e); i = i.concat(l) } return { estimatedPoints: o, opset: { type: "path", ops: i } } } function Ns(n, t, e, s, r, o, i, a, l) { const c = n, u = t; let f = Math.abs(e / 2), g = Math.abs(s / 2); f += M(f * .01, l), g += M(g * .01, l); let h = r, p = o; for (; h < 0;)h += Math.PI * 2, p += Math.PI * 2; p - h > Math.PI * 2 && (h = 0, p = Math.PI * 2); const d = Math.PI * 2 / l.curveStepCount, m = Math.min(d / 2, (p - h) / 2), _ = Vs(m, c, u, f, g, h, p, 1, l); if (!l.disableMultiStroke) { const y = Vs(m, c, u, f, g, h, p, 1.5, l); _.push(...y) } return i && (a ? _.push(...ft(c, u, c + f * Math.cos(h), u + g * Math.sin(h), l), ...ft(c, u, c + f * Math.cos(p), u + g * Math.sin(p), l)) : _.push({ op: "lineTo", data: [c, u] }, { op: "lineTo", data: [c + f * Math.cos(h), u + g * Math.sin(h)] })), { type: "path", ops: _ } } function js(n, t) { const e = $r(Or(qn(n))), s = []; let r = [0, 0], o = [0, 0]; for (const { key: i, data: a } of e) switch (i) { case "M": { o = [a[0], a[1]], r = [a[0], a[1]]; break } case "L": s.push(...ft(o[0], o[1], a[0], a[1], t)), o = [a[0], a[1]]; break; case "C": { const [l, c, u, f, g, h] = a; s.push(...Hl(l, c, u, f, g, h, o, t)), o = [g, h]; break } case "Z": s.push(...ft(o[0], o[1], r[0], r[1], t)), o = [r[0], r[1]]; break }return { type: "path", ops: s } } function fn(n, t) { const e = []; for (const s of n) if (s.length) { const r = t.maxRandomnessOffset || 0, o = s.length; if (o > 2) { e.push({ op: "move", data: [s[0][0] + M(r, t), s[0][1] + M(r, t)] }); for (let i = 1; i < o; i++)e.push({ op: "lineTo", data: [s[i][0] + M(r, t), s[i][1] + M(r, t)] }) } } return { type: "fillPath", ops: e } } function Yt(n, t) { return El(t, Cl).fillPolygons(n, t) } function Il(n, t, e, s, r, o, i) { const a = n, l = t; let c = Math.abs(e / 2), u = Math.abs(s / 2); c += M(c * .01, i), u += M(u * .01, i); let f = r, g = o; for (; f < 0;)f += Math.PI * 2, g += Math.PI * 2; g - f > Math.PI * 2 && (f = 0, g = Math.PI * 2); const h = (g - f) / i.curveStepCount, p = []; for (let d = f; d <= g; d = d + h)p.push([a + c * Math.cos(d), l + u * Math.sin(d)]); return p.push([a + c * Math.cos(g), l + u * Math.sin(g)]), p.push([a, l]), Yt([p], i) } function Rl(n, t) { return M(n, t) } function Nl(n, t, e) { return qe(n, t, e) } function jl(n, t, e, s, r) { return ft(n, t, e, s, r, !0) } function Hs(n) { const t = Object.assign({}, n); return t.randomizer = void 0, n.seed && (t.seed = n.seed + 1), t } function Pr(n) { return n.randomizer || (n.randomizer = new _l(n.seed || 0)), n.randomizer.next() } function qe(n, t, e, s = 1) { return e.roughness * s * (Pr(e) * (t - n) + n) } function M(n, t, e = 1) { return qe(-n, n, t, e) } function ft(n, t, e, s, r, o = !1) { const i = o ? r.disableMultiStrokeFill : r.disableMultiStroke, a = Ln(n, t, e, s, r, !0, !1); if (i) return a; const l = Ln(n, t, e, s, r, !0, !0); return a.concat(l) } function Ln(n, t, e, s, r, o, i) { const a = Math.pow(n - e, 2) + Math.pow(t - s, 2), l = Math.sqrt(a); let c = 1; l < 200 ? c = 1 : l > 500 ? c = .4 : c = -.0016668 * l + 1.233334; let u = r.maxRandomnessOffset || 0; u * u * 100 > a && (u = l / 10); const f = u / 2, g = .2 + Pr(r) * .2; let h = r.bowing * r.maxRandomnessOffset * (s - t) / 200, p = r.bowing * r.maxRandomnessOffset * (n - e) / 200; h = M(h, r, c), p = M(p, r, c); const d = [], m = () => M(f, r, c), _ = () => M(u, r, c), y = r.preserveVertices; return i ? d.push({ op: "move", data: [n + (y ? 0 : m()), t + (y ? 0 : m())] }) : d.push({ op: "move", data: [n + (y ? 0 : M(u, r, c)), t + (y ? 0 : M(u, r, c))] }), i ? d.push({ op: "bcurveTo", data: [h + n + (e - n) * g + m(), p + t + (s - t) * g + m(), h + n + 2 * (e - n) * g + m(), p + t + 2 * (s - t) * g + m(), e + (y ? 0 : m()), s + (y ? 0 : m())] }) : d.push({ op: "bcurveTo", data: [h + n + (e - n) * g + _(), p + t + (s - t) * g + _(), h + n + 2 * (e - n) * g + _(), p + t + 2 * (s - t) * g + _(), e + (y ? 0 : _()), s + (y ? 0 : _())] }), d } function Te(n, t, e) { if (!n.length) return []; const s = []; s.push([n[0][0] + M(t, e), n[0][1] + M(t, e)]), s.push([n[0][0] + M(t, e), n[0][1] + M(t, e)]); for (let r = 1; r < n.length; r++)s.push([n[r][0] + M(t, e), n[r][1] + M(t, e)]), r === n.length - 1 && s.push([n[r][0] + M(t, e), n[r][1] + M(t, e)]); return We(s, null, e) } function We(n, t, e) { const s = n.length, r = []; if (s > 3) { const o = [], i = 1 - e.curveTightness; r.push({ op: "move", data: [n[1][0], n[1][1]] }); for (let a = 1; a + 2 < s; a++) { const l = n[a]; o[0] = [l[0], l[1]], o[1] = [l[0] + (i * n[a + 1][0] - i * n[a - 1][0]) / 6, l[1] + (i * n[a + 1][1] - i * n[a - 1][1]) / 6], o[2] = [n[a + 1][0] + (i * n[a][0] - i * n[a + 2][0]) / 6, n[a + 1][1] + (i * n[a][1] - i * n[a + 2][1]) / 6], o[3] = [n[a + 1][0], n[a + 1][1]], r.push({ op: "bcurveTo", data: [o[1][0], o[1][1], o[2][0], o[2][1], o[3][0], o[3][1]] }) } } else s === 3 ? (r.push({ op: "move", data: [n[1][0], n[1][1]] }), r.push({ op: "bcurveTo", data: [n[1][0], n[1][1], n[2][0], n[2][1], n[2][0], n[2][1]] })) : s === 2 && r.push(...Ln(n[0][0], n[0][1], n[1][0], n[1][1], e, !0, !0)); return r } function xs(n, t, e, s, r, o, i, a) { const l = a.roughness === 0, c = [], u = []; if (l) { n = n / 4, u.push([t + s * Math.cos(-n), e + r * Math.sin(-n)]); for (let f = 0; f <= Math.PI * 2; f = f + n) { const g = [t + s * Math.cos(f), e + r * Math.sin(f)]; c.push(g), u.push(g) } u.push([t + s * Math.cos(0), e + r * Math.sin(0)]), u.push([t + s * Math.cos(n), e + r * Math.sin(n)]) } else { const f = M(.5, a) - Math.PI / 2; u.push([M(o, a) + t + .9 * s * Math.cos(f - n), M(o, a) + e + .9 * r * Math.sin(f - n)]); const g = Math.PI * 2 + f - .01; for (let h = f; h < g; h = h + n) { const p = [M(o, a) + t + s * Math.cos(h), M(o, a) + e + r * Math.sin(h)]; c.push(p), u.push(p) } u.push([M(o, a) + t + s * Math.cos(f + Math.PI * 2 + i * .5), M(o, a) + e + r * Math.sin(f + Math.PI * 2 + i * .5)]), u.push([M(o, a) + t + .98 * s * Math.cos(f + i), M(o, a) + e + .98 * r * Math.sin(f + i)]), u.push([M(o, a) + t + .9 * s * Math.cos(f + i * .5), M(o, a) + e + .9 * r * Math.sin(f + i * .5)]) } return [u, c] } function Vs(n, t, e, s, r, o, i, a, l) { const c = o + M(.1, l), u = []; u.push([M(a, l) + t + .9 * s * Math.cos(c - n), M(a, l) + e + .9 * r * Math.sin(c - n)]); for (let f = c; f <= i; f = f + n)u.push([M(a, l) + t + s * Math.cos(f), M(a, l) + e + r * Math.sin(f)]); return u.push([t + s * Math.cos(i), e + r * Math.sin(i)]), u.push([t + s * Math.cos(i), e + r * Math.sin(i)]), We(u, null, l) } function Hl(n, t, e, s, r, o, i, a) { const l = [], c = [a.maxRandomnessOffset || 1, (a.maxRandomnessOffset || 1) + .3]; let u = [0, 0]; const f = a.disableMultiStroke ? 1 : 2, g = a.preserveVertices; for (let h = 0; h < f; h++)h === 0 ? l.push({ op: "move", data: [i[0], i[1]] }) : l.push({ op: "move", data: [i[0] + (g ? 0 : M(c[0], a)), i[1] + (g ? 0 : M(c[0], a))] }), u = g ? [r, o] : [r + M(c[h], a), o + M(c[h], a)], l.push({ op: "bcurveTo", data: [n + M(c[h], a), t + M(c[h], a), e + M(c[h], a), s + M(c[h], a), u[0], u[1]] }); return l } function de(n) { return [...n] } function Fs(n, t = 0) { const e = n.length; if (e < 3) throw new Error("A curve must have at least three points."); const s = []; if (e === 3) s.push(de(n[0]), de(n[1]), de(n[2]), de(n[2])); else { const r = []; r.push(n[0], n[0]); for (let a = 1; a < n.length; a++)r.push(n[a]), a === n.length - 1 && r.push(n[a]); const o = [], i = 1 - t; s.push(de(r[0])); for (let a = 1; a + 2 < r.length; a++) { const l = r[a]; o[0] = [l[0], l[1]], o[1] = [l[0] + (i * r[a + 1][0] - i * r[a - 1][0]) / 6, l[1] + (i * r[a + 1][1] - i * r[a - 1][1]) / 6], o[2] = [r[a + 1][0] + (i * r[a][0] - i * r[a + 2][0]) / 6, r[a + 1][1] + (i * r[a][1] - i * r[a + 2][1]) / 6], o[3] = [r[a + 1][0], r[a + 1][1]], s.push(o[1], o[2], o[3]) } } return s } function xl(n, t) { return Math.sqrt(Ne(n, t)) } function Ne(n, t) { return Math.pow(n[0] - t[0], 2) + Math.pow(n[1] - t[1], 2) } function Vl(n, t, e) { const s = Ne(t, e); if (s === 0) return Ne(n, t); let r = ((n[0] - t[0]) * (e[0] - t[0]) + (n[1] - t[1]) * (e[1] - t[1])) / s; return r = Math.max(0, Math.min(1, r)), Ne(n, Wt(t, e, r)) } function Wt(n, t, e) { return [n[0] + (t[0] - n[0]) * e, n[1] + (t[1] - n[1]) * e] } function Fl(n, t) { const e = n[t + 0], s = n[t + 1], r = n[t + 2], o = n[t + 3]; let i = 3 * s[0] - 2 * e[0] - o[0]; i *= i; let a = 3 * s[1] - 2 * e[1] - o[1]; a *= a; let l = 3 * r[0] - 2 * o[0] - e[0]; l *= l; let c = 3 * r[1] - 2 * o[1] - e[1]; return c *= c, i < l && (i = l), a < c && (a = c), i + a } function En(n, t, e, s) { const r = s || []; if (Fl(n, t) < e) { const o = n[t + 0]; r.length ? xl(r[r.length - 1], o) > 1 && r.push(o) : r.push(o), r.push(n[t + 3]) } else { const i = n[t + 0], a = n[t + 1], l = n[t + 2], c = n[t + 3], u = Wt(i, a, .5), f = Wt(a, l, .5), g = Wt(l, c, .5), h = Wt(u, f, .5), p = Wt(f, g, .5), d = Wt(h, p, .5); En([i, u, h, d], 0, e, r), En([d, p, g, c], 0, e, r) } return r } function zl(n, t) { return Ue(n, 0, n.length, t) } function Ue(n, t, e, s, r) { const o = r || [], i = n[t], a = n[e - 1]; let l = 0, c = 1; for (let u = t + 1; u < e - 1; ++u) { const f = Vl(n[u], i, a); f > l && (l = f, c = u) } return Math.sqrt(l) > s ? (Ue(n, t, c + 1, s, o), Ue(n, c, e, s, o)) : (o.length || o.push(i), o.push(a)), o } function Tn(n, t = .15, e) { const s = [], r = (n.length - 1) / 3; for (let o = 0; o < r; o++) { const i = o * 3; En(n, i, t, s) } return e && e > 0 ? Ue(s, 0, s.length, e) : s } function Bl(n, t, e) { const s = qn(n), r = $r(Or(s)), o = []; let i = [], a = [0, 0], l = []; const c = () => { l.length >= 4 && i.push(...Tn(l, t)), l = [] }, u = () => { c(), i.length && (o.push(i), i = []) }; for (const { key: g, data: h } of r) switch (g) { case "M": u(), a = [h[0], h[1]], i.push(a); break; case "L": c(), i.push([h[0], h[1]]); break; case "C": if (!l.length) { const p = i.length ? i[i.length - 1] : a; l.push([p[0], p[1]]) } l.push([h[0], h[1]]), l.push([h[2], h[3]]), l.push([h[4], h[5]]); break; case "Z": c(), i.push([a[0], a[1]]); break }if (u(), !e) return o; const f = []; for (const g of o) { const h = zl(g, e); h.length && f.push(h) } return f } const Q = "none"; class ql { constructor(t) { this.defaultOptions = { maxRandomnessOffset: 2, roughness: 1, bowing: 1, stroke: "#000", strokeWidth: 1, curveTightness: 0, curveFitting: .95, curveStepCount: 9, fillStyle: "hachure", fillWeight: -1, hachureAngle: -41, hachureGap: -1, dashOffset: -1, dashGap: -1, zigzagOffset: -1, seed: 0, disableMultiStroke: !1, disableMultiStrokeFill: !1, preserveVertices: !1, fillShapeRoughnessGain: .8 }, this.config = t || {}, this.config.options && (this.defaultOptions = this._o(this.config.options)) } static newSeed() { return Sr() } _o(t) { return t ? Object.assign({}, this.defaultOptions, t) : this.defaultOptions } _d(t, e, s) { return { shape: t, sets: e || [], options: s || this.defaultOptions } } line(t, e, s, r, o) { const i = this._o(o); return this._d("line", [X(t, e, s, r, i)], i) } rectangle(t, e, s, r, o) { const i = this._o(o), a = [], l = Er(t, e, s, r, i); if (i.fill) { const c = [[t, e], [t + s, e], [t + s, e + r], [t, e + r]]; i.fillStyle === "solid" ? a.push(fn([c], i)) : a.push(Yt([c], i)) } return i.stroke !== Q && a.push(l), this._d("rectangle", a, i) } ellipse(t, e, s, r, o) { const i = this._o(o), a = [], l = Tr(s, r, i), c = $n(t, e, i, l); if (i.fill) if (i.fillStyle === "solid") { const u = $n(t, e, i, l).opset; u.type = "fillPath", a.push(u) } else a.push(Yt([c.estimatedPoints], i)); return i.stroke !== Q && a.push(c.opset), this._d("ellipse", a, i) } circle(t, e, s, r) { const o = this.ellipse(t, e, s, s, r); return o.shape = "circle", o } linearPath(t, e) { const s = this._o(e); return this._d("linearPath", [me(t, !1, s)], s) } arc(t, e, s, r, o, i, a = !1, l) { const c = this._o(l), u = [], f = Ns(t, e, s, r, o, i, a, !0, c); if (a && c.fill) if (c.fillStyle === "solid") { const g = Object.assign({}, c); g.disableMultiStroke = !0; const h = Ns(t, e, s, r, o, i, !0, !1, g); h.type = "fillPath", u.push(h) } else u.push(Il(t, e, s, r, o, i, c)); return c.stroke !== Q && u.push(f), this._d("arc", u, c) } curve(t, e) { const s = this._o(e), r = [], o = Rs(t, s); if (s.fill && s.fill !== Q) if (s.fillStyle === "solid") { const i = Rs(t, Object.assign(Object.assign({}, s), { disableMultiStroke: !0, roughness: s.roughness ? s.roughness + s.fillShapeRoughnessGain : 0 })); r.push({ type: "fillPath", ops: this._mergedShape(i.ops) }) } else { const i = [], a = t; if (a.length) { const c = typeof a[0][0] == "number" ? [a] : a; for (const u of c) u.length < 3 ? i.push(...u) : u.length === 3 ? i.push(...Tn(Fs([u[0], u[0], u[1], u[2]]), 10, (1 + s.roughness) / 2)) : i.push(...Tn(Fs(u), 10, (1 + s.roughness) / 2)) } i.length && r.push(Yt([i], s)) } return s.stroke !== Q && r.push(o), this._d("curve", r, s) } polygon(t, e) { const s = this._o(e), r = [], o = me(t, !0, s); return s.fill && (s.fillStyle === "solid" ? r.push(fn([t], s)) : r.push(Yt([t], s))), s.stroke !== Q && r.push(o), this._d("polygon", r, s) } path(t, e) { const s = this._o(e), r = []; if (!t) return this._d("path", r, s); t = (t || "").replace(/\n/g, " ").replace(/(-\s)/g, "-").replace("/(ss)/g", " "); const o = s.fill && s.fill !== "transparent" && s.fill !== Q, i = s.stroke !== Q, a = !!(s.simplification && s.simplification < 1), l = a ? 4 - 4 * (s.simplification || 1) : (1 + s.roughness) / 2, c = Bl(t, 1, l), u = js(t, s); if (o) if (s.fillStyle === "solid") if (c.length === 1) { const f = js(t, Object.assign(Object.assign({}, s), { disableMultiStroke: !0, roughness: s.roughness ? s.roughness + s.fillShapeRoughnessGain : 0 })); r.push({ type: "fillPath", ops: this._mergedShape(f.ops) }) } else r.push(fn(c, s)); else r.push(Yt(c, s)); return i && (a ? c.forEach(f => { r.push(me(f, !1, s)) }) : r.push(u)), this._d("path", r, s) } opsToPath(t, e) { let s = ""; for (const r of t.ops) { const o = typeof e == "number" && e >= 0 ? r.data.map(i => +i.toFixed(e)) : r.data; switch (r.op) { case "move": s += `M${o[0]} ${o[1]} `; break; case "bcurveTo": s += `C${o[0]} ${o[1]}, ${o[2]} ${o[3]}, ${o[4]} ${o[5]} `; break; case "lineTo": s += `L${o[0]} ${o[1]} `; break } } return s.trim() } toPaths(t) { const e = t.sets || [], s = t.options || this.defaultOptions, r = []; for (const o of e) { let i = null; switch (o.type) { case "path": i = { d: this.opsToPath(o), stroke: s.stroke, strokeWidth: s.strokeWidth, fill: Q }; break; case "fillPath": i = { d: this.opsToPath(o), stroke: Q, strokeWidth: 0, fill: s.fill || Q }; break; case "fillSketch": i = this.fillSketch(o, s); break }i && r.push(i) } return r } fillSketch(t, e) { let s = e.fillWeight; return s < 0 && (s = e.strokeWidth / 2), { d: this.opsToPath(t), stroke: e.fill || Q, strokeWidth: s, fill: Q } } _mergedShape(t) { return t.filter((e, s) => s === 0 ? !0 : e.op !== "move") } } const Ar = "http://www.w3.org/2000/svg", Wl = 800; let dn = null; function Ul() { return dn || (dn = new ql().defaultOptions), dn } function hn(n, t, e) { return { ...Ul(), maxRandomnessOffset: 2, roughness: n === "highlight" ? 3 : 1.5, bowing: 1, stroke: "#000", strokeWidth: 1.5, curveTightness: 0, curveFitting: .95, curveStepCount: 9, fillStyle: "hachure", fillWeight: -1, hachureAngle: -41, hachureGap: -1, dashOffset: -1, dashGap: -1, zigzagOffset: -1, disableMultiStroke: n !== "double", disableMultiStrokeFill: !1, seed: t, ...e } } function Jl(n) { const t = n.padding; if (t || t === 0) { if (typeof t == "number") return [t, t, t, t]; if (Array.isArray(t)) { const e = t; if (e.length) switch (e.length) { case 4: return [...e]; case 1: return [e[0], e[0], e[0], e[0]]; case 2: return [...e, ...e]; case 3: return [...e, e[1]]; default: return [e[0], e[1], e[2], e[3]] } } } return [5, 5, 5, 5] } function Kl(n, t, e, s, r, o) { const i = []; let a = e.strokeWidth || 2; const l = Jl(e), c = e.animate === void 0 ? !0 : !!e.animate, u = e.iterations || 2, f = e.rtl ? 1 : 0, g = hn("single", o, e); switch (e.type) { case "underline": { const h = t.y + t.h + l[2]; for (let p = f; p < u + f; p++)p % 2 ? i.push(X(t.x + t.w, h, t.x, h, g)) : i.push(X(t.x, h, t.x + t.w, h, g)); break } case "strike-through": { const h = t.y + t.h / 2; for (let p = f; p < u + f; p++)p % 2 ? i.push(X(t.x + t.w, h, t.x, h, g)) : i.push(X(t.x, h, t.x + t.w, h, g)); break } case "box": { const h = t.x - l[3], p = t.y - l[0], d = t.w + (l[1] + l[3]), m = t.h + (l[0] + l[2]); for (let _ = 0; _ < u; _++)i.push(Er(h, p, d, m, g)); break } case "bracket": { const h = Array.isArray(e.brackets) ? e.brackets : e.brackets ? [e.brackets] : ["right"], p = t.x - l[3] * 2, d = t.x + t.w + l[1] * 2, m = t.y - l[0] * 2, _ = t.y + t.h + l[2] * 2; for (const y of h) { let k; switch (y) { case "bottom": k = [[p, t.y + t.h], [p, _], [d, _], [d, t.y + t.h]]; break; case "top": k = [[p, t.y], [p, m], [d, m], [d, t.y]]; break; case "left": k = [[t.x, m], [p, m], [p, _], [t.x, _]]; break; case "right": k = [[t.x + t.w, m], [d, m], [d, _], [t.x + t.w, _]]; break }k && i.push(me(k, !1, g)) } break } case "crossed-off": { const h = t.x, p = t.y, d = h + t.w, m = p + t.h; for (let _ = f; _ < u + f; _++)_ % 2 ? i.push(X(d, m, h, p, g)) : i.push(X(h, p, d, m, g)); for (let _ = f; _ < u + f; _++)_ % 2 ? i.push(X(h, m, d, p, g)) : i.push(X(d, p, h, m, g)); break } case "circle": { const h = hn("double", o, e), p = t.w + (l[1] + l[3]), d = t.h + (l[0] + l[2]), m = t.x - l[3] + p / 2, _ = t.y - l[0] + d / 2, y = Math.floor(u / 2), k = u - y * 2; for (let w = 0; w < y; w++)i.push(On(m, _, p, d, h)); for (let w = 0; w < k; w++)i.push(On(m, _, p, d, g)); break } case "highlight": { const h = hn("highlight", o, e); a = t.h * .95; const p = t.y + t.h / 2; for (let d = f; d < u + f; d++)d % 2 ? i.push(X(t.x + t.w, p, t.x, p, h)) : i.push(X(t.x, p, t.x + t.w, p, h)); break } }if (i.length) { const h = Gl(i), p = [], d = []; let m = 0; const _ = (y, k, w) => y.setAttribute(k, w); for (const y of h) { const k = document.createElementNS(Ar, "path"); if (_(k, "d", y), _(k, "fill", "none"), _(k, "stroke", e.color || "currentColor"), _(k, "stroke-width", `${a}`), e.opacity !== void 0 && _(k, "style", `opacity:${e.opacity}`), c) { const w = k.getTotalLength(); p.push(w), m += w } n.appendChild(k), d.push(k) } if (c) { let y = 0; for (let k = 0; k < d.length; k++) { const w = d[k], b = p[k], O = m ? r * (b / m) : 0, L = s + y, I = w.style; I.strokeDashoffset = `${b}`, I.strokeDasharray = `${b}`, I.animation = `rough-notation-dash ${O}ms ease-out ${L}ms forwards`, y += O } return zs(r + s) } } return zs(0) } function zs(n) { return new Promise(t => setTimeout(t, n)) } function Gl(n) { const t = []; for (const e of n) { let s = ""; for (const r of e.ops) { const o = r.data; switch (r.op) { case "move": s.trim() && t.push(s.trim()), s = `M${o[0]} ${o[1]} `; break; case "bcurveTo": s += `C${o[0]} ${o[1]}, ${o[2]} ${o[3]}, ${o[4]} ${o[5]} `; break; case "lineTo": s += `L${o[0]} ${o[1]} `; break } } s.trim() && t.push(s.trim()) } return t } function Ql() { if (!window.__rno_kf_s) { const n = window.__rno_kf_s = document.createElement("style"); n.textContent = "@keyframes rough-notation-dash { to { stroke-dashoffset: 0; } }", document.head.appendChild(n) } } var Yl = Object.defineProperty, Zl = (n, t, e) => t in n ? Yl(n, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : n[t] = e, nt = (n, t, e) => (Zl(n, typeof t != "symbol" ? t + "" : t, e), e); class Xl { constructor(t, e) { nt(this, "_state", "unattached"), nt(this, "_config"), nt(this, "_resizing", !1), nt(this, "_ro"), nt(this, "_seed", Sr()), nt(this, "_e"), nt(this, "_svg"), nt(this, "_lastSizes", []), nt(this, "_animationDelay", 0), nt(this, "_resizeListener", () => { this._resizing || (this._resizing = !0, setTimeout(() => { this._resizing = !1, this._state === "showing" && this.haveRectsChanged() && this.show() }, 400)) }), nt(this, "pendingRefresh"), this._e = t, this._config = JSON.parse(JSON.stringify(e)), this.attach() } getConfig(t) { return this._config[t] } setConfig(t, e) { this._config[t] !== e && (this._config[t] = e, this.refresh()) } get animate() { return this._config.animate } set animate(t) { this._config.animate = t } get animationDuration() { return this._config.animationDuration } set animationDuration(t) { this._config.animationDuration = t } get iterations() { return this._config.iterations } set iterations(t) { this._config.iterations = t } get color() { return this._config.color } set color(t) { this._config.color !== t && (this._config.color = t, this.refresh()) } get class() { return this._config.class } set class(t) { this._config.class !== t && (this._config.class = t, this._svg && this._svg.setAttribute("class", ["rough-annotation", this._config.class || ""].filter(Boolean).join(" "))) } get strokeWidth() { return this._config.strokeWidth } set strokeWidth(t) { this._config.strokeWidth !== t && (this._config.strokeWidth = t, this.refresh()) } get padding() { return this._config.padding } set padding(t) { this._config.padding !== t && (this._config.padding = t, this.refresh()) } attach() { if (this._state === "unattached" && this._e.parentElement) { Ql(); const t = this._svg = document.createElementNS(Ar, "svg"); t.setAttribute("class", ["rough-annotation", this._config.class || ""].filter(Boolean).join(" ")); const e = t.style; e.position = "absolute", e.top = "0", e.left = "0", e.overflow = "visible", e.pointerEvents = "none", e.width = "100px", e.height = "100px"; const s = this._config.type === "highlight"; if (this._e.insertAdjacentElement(s ? "beforebegin" : "afterend", t), this._state = "not-showing", s) { const r = window.getComputedStyle(this._e).position; (!r || r === "static") && (this._e.style.position = "relative") } this.attachListeners() } } detachListeners() { window.removeEventListener("resize", this._resizeListener), this._ro && this._ro.unobserve(this._e) } attachListeners() { this.detachListeners(), window.addEventListener("resize", this._resizeListener, { passive: !0 }), !this._ro && "ResizeObserver" in window && (this._ro = new window.ResizeObserver(t => { for (const e of t) e.contentRect && this._resizeListener() })), this._ro && this._ro.observe(this._e) } haveRectsChanged() { if (this._lastSizes.length) { const t = this.rects(); if (t.length === this._lastSizes.length) { for (let e = 0; e < t.length; e++)if (!this.isSameRect(t[e], this._lastSizes[e])) return !0 } else return !0 } return !1 } isSameRect(t, e) { const s = (r, o) => Math.round(r) === Math.round(o); return s(t.x, e.x) && s(t.y, e.y) && s(t.w, e.w) && s(t.h, e.h) } isShowing() { return this._state !== "not-showing" } refresh() { this.isShowing() && !this.pendingRefresh && (this.pendingRefresh = Promise.resolve().then(() => { this.isShowing() && this.show(), delete this.pendingRefresh })) } async show() { switch (this._state) { case "unattached": break; case "showing": this.hide(), this._svg && await this.render(this._svg, !0); break; case "not-showing": this.attach(), this._svg && await this.render(this._svg, !1); break } } hide() { if (this._svg) for (; this._svg.lastChild;)this._svg.removeChild(this._svg.lastChild); this._state = "not-showing" } remove() { this._svg && this._svg.parentElement && this._svg.parentElement.removeChild(this._svg), this._svg = void 0, this._state = "unattached", this.detachListeners() } async render(t, e) { let s = this._config; e && (s = JSON.parse(JSON.stringify(this._config)), s.animate = !1); const r = this.rects(); let o = 0; r.forEach(c => o += c.w); const i = s.animationDuration || Wl; let a = 0; const l = []; for (let c = 0; c < r.length; c++) { const u = r[c], f = i * (u.w / o); l.push(Kl(t, r[c], s, a + this._animationDelay + (this._config.delay || 0), f, this._seed)), a += f } return this._lastSizes = r, this._state = "showing", await Promise.all(l) } rects() { const t = []; if (this._svg) if (this._config.multiline) { const e = this._e.getClientRects(); for (let s = 0; s < e.length; s++)t.push(this.svgRect(this._svg, e[s])) } else t.push(this.svgRect(this._svg, this._e.getBoundingClientRect())); return t } svgRect(t, e) { const s = t.getBoundingClientRect(), r = e; return { x: (r.x || r.left) - (s.x || s.left), y: (r.y || r.top) - (s.y || s.top), w: r.width, h: r.height } } } function tc(n, t) { return new Xl(n, t) } function G(n, t) { return n.class = [n.class, t].filter(Boolean).join(" "), n } const Bs = { box: n => Object.assign(n, { type: "box" }), circle: n => Object.assign(n, { type: "circle" }), underline: n => Object.assign(n, { type: "underline" }), highlight: n => Object.assign(n, { type: "highlight" }), "strike-through": n => Object.assign(n, { type: "strike-through" }), "crossed-off": n => Object.assign(n, { type: "crossed-off" }), bracket: n => Object.assign(n, { type: "bracket" }), strike: n => Object.assign(n, { type: "strike-through" }), cross: n => Object.assign(n, { type: "crossed-off" }), crossed: n => Object.assign(n, { type: "crossed-off" }), linethrough: n => Object.assign(n, { type: "strike-through" }), "line-through": n => Object.assign(n, { type: "strike-through" }), black: n => G(n, "text-black"), blue: n => G(n, "text-blue"), cyan: n => G(n, "text-cyan"), gray: n => G(n, "text-gray"), green: n => G(n, "text-green"), indigo: n => G(n, "text-indigo"), lime: n => G(n, "text-lime"), orange: n => G(n, "text-orange"), pink: n => G(n, "text-pink"), purple: n => G(n, "text-purple"), red: n => G(n, "text-red"), teal: n => G(n, "text-teal"), white: n => G(n, "text-white"), yellow: n => G(n, "text-yellow") }, ec = [[/^delay-?(\d+)?$/, (n, t, e) => { const s = (n[1] ? Number.parseInt(n[1]) : e) || 300; return t.delay = s, t }], [/^(?:op|opacity)-?(\d+)?$/, (n, t, e) => { const s = (n[1] ? Number.parseInt(n[1]) : e) || 100; return t.opacity = s / 100, t }]]; function nc() { return { install(n) { n.directive("mark", { name: "v-mark", mounted: (t, e) => { const { isPrintMode: s } = re(), r = S(() => { const a = typeof e.value == "object" && !Array.isArray(e.value) ? { ...e.value } : { at: e.value }; let l = { at: a.at }; const c = Object.entries(e.modifiers).filter(([f, g]) => { if (Bs[f]) return l = Bs[f](l, g), !1; for (const [h, p] of ec) { const d = f.match(h); if (d) return l = p(d, l, g), !1 } return !0 }); c.length && console.warn("[Slidev] Invalid modifiers for v-mark:", c); const u = { ...l, ...a }; return u.type || (u.type = "underline"), s.value && (u.animationDuration = 1), u }), o = tc(t, r.value), i = Re(t, e, r.value.at); if (!i) { o.show(); return } t.watchStopHandle = ne(() => { let a; r.value.class && (o.class = r.value.class), r.value.color && (o.color = r.value.color); const l = r.value.at; l === !0 ? a = !0 : l === !1 ? a = !1 : a = i.isActive.value, a != null && (a ? o.show() : o.hide()) }) }, unmounted: t => { var e; (e = t.watchStopHandle) == null || e.call(t) } }) } } } function sc() { return { install(n) { const t = oo(); n.directive("motion", { name: "v-motion", mounted(e, s, r, o) { var k, w, b; const i = se(s, Ke), a = se(s, Cn), l = se(s, Dn), { currentPage: c, clicks: u, isPrintMode: f } = re(), g = r.props = { ...r.props }, h = { ...g.initial, ...(k = g.variants) == null ? void 0 : k["slidev-initial"] }, p = { ...g.enter, ...(w = g.variants) == null ? void 0 : w["slidev-enter"] }, d = { ...g.leave, ...(b = g.variants) == null ? void 0 : b["slidev-leave"] }; delete g.initial, delete g.enter, delete g.leave; const m = `${zn()}-`, _ = []; for (const O of Object.keys(g)) if (O.startsWith("click-")) { const L = O.slice(6), I = L.includes("-") ? L.split("-").map(Number) : +L, V = m + L; _.push({ id: V, at: I, variant: { ...g[O] }, info: i == null ? void 0 : i.value.calculate(I) }), delete g[O] } _.sort((O, L) => (Array.isArray(O.at) ? O.at[0] : O.at) - (Array.isArray(L.at) ? L.at[0] : L.at)), t.created(e, s, r, o), t.mounted(e, s, r, o); const y = e.motionInstance; y.clickIds = _.map(O => O.id), y.set(h), y.watchStopHandle = ot([a, c, u].filter(Boolean), () => { var L; const O = ((L = br.get(e)) == null ? void 0 : L.visibilityState.value) ?? "shown"; if (!(i != null && i.value) || !["slide", "presenter"].includes((l == null ? void 0 : l.value) ?? "")) { const I = { ...h, ...p }; for (const { variant: V } of _) Object.assign(I, V); y.set(I) } else if (f.value || (a == null ? void 0 : a.value) === c.value) if (O === "shown") { const I = { ...h, ...p }; for (const { variant: V, info: et } of _) (!et || et.isActive.value) && Object.assign(I, V); f.value ? y.set(I) : y.apply(I) } else y.apply(O === "before" ? h : d); else y.apply(((a == null ? void 0 : a.value) ?? -1) > c.value ? h : d) }, { immediate: !0 }) }, unmounted(e) { e.motionInstance.watchStopHandle() } }) } } } const rc = []; function oc() { const n = []; function t(e) { if (!J.remote || J.remote === e.query.password) return !0; if (J.remote && e.query.password === void 0) { const s = prompt("Enter password"); if (J.remote === s) return !0 } return e.params.no ? { path: `/${e.params.no}` } : { path: "" } } return n.push({ name: "entry", path: "/entry", component: () => $(() => import("./slidev/entry-DfZBjPkM.js"), __vite__mapDeps([50, 2, 4, 5, 6, 7, 8, 51])), beforeEnter: t }, { name: "overview", path: "/overview", component: () => $(() => import("./slidev/overview-velCqymH.js"), __vite__mapDeps([52, 1, 2, 4, 5, 6, 53, 54, 55, 3, 56, 57, 7, 8])), beforeEnter: t }, { name: "notes", path: "/notes", component: () => $(() => import("./slidev/notes-CrVn7Iap.js"), __vite__mapDeps([58, 2, 4, 5, 6, 53, 54, 57, 7, 8])), beforeEnter: t }, { name: "presenter", path: "/presenter/:no", component: () => $(() => import("./slidev/presenter-kGzephC-.js"), __vite__mapDeps([59, 2, 55, 4, 5, 6, 3, 56, 60, 17, 1, 57, 7, 8, 61, 53, 54, 62, 63, 64])), beforeEnter: t }, { path: "/presenter", redirect: { path: "/presenter/1" } }), n.push({ name: "play", path: "/:no", component: () => $(() => import("./slidev/play-LOwe0LLh.js"), __vite__mapDeps([65, 2, 55, 4, 5, 6, 3, 56, 60, 17, 1, 57, 7, 8, 61, 66])) }, { path: "", redirect: { path: "/1" } }, { path: "/:pathMatch(.*)*", name: "NotFound", component: () => $(() => import("./slidev/404-t6LltpjP.js"), __vite__mapDeps([67, 2, 4, 5, 6, 7, 8, 68])) }), rc.reduce((e, s) => s(e), n) } async function ic(n) { function t() { document.documentElement.style.setProperty("--vh", `${window.innerHeight * .01}px`) } t(), window.addEventListener("resize", t); const e = io({ history: ao("/service-domain-review"), routes: oc() }); n.use(e), n.use(dl()), n.use(hl()), n.use(nc()), n.use(yl()), n.use(sc()), n.use(mo, { container: "#twoslash-container" }); const s = { app: n, router: e }; for (const r of cl) await r(s) } async function ac() { const n = lo(ll); await ic(n), n.mount("#app") } ac(); export { mc as $, Ac as A, Lc as B, Ae as C, $c as D, pc as E, da as F, gc as G, hc as H, wc as I, Sa as J, vn as K, ka as L, Ge as M, Nc as N, Rc as O, Sc as P, Ic as Q, tt as R, vr as S, kr as T, _a as U, rr as V, Hc as W, Oc as X, Cc as Y, xe as Z, Uo as _, Ke as a, or as a0, Me as a1, vc as a2, xc as a3, Tc as a4, Ec as a5, st as a6, ya as a7, pl as a8, kc as a9, In as aa, yc as ab, be as ac, _c as ad, Mc as ae, Cn as b, Dn as c, ca as d, dc as e, aa as f, ua as g, ce as h, la as i, zo as j, re as k, nr as l, zn as m, bc as n, Pe as o, sr as p, Zt as q, Wo as r, jc as s, ml as t, Dc as u, _n as v, Se as w, va as x, Ve as y, Pc as z };
